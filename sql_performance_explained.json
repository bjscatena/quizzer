[
    {
        "chapter": 1,
        "question": "Qual Ã© a principal estrutura de dados que a maioria dos bancos de dados SQL relacionais utiliza para implementar Ã­ndices?",
        "options": [
            "A) Hash Table",
            "B) B-Tree (ou suas variaÃ§Ãµes como B+Tree)",
            "C) Linked List",
            "D) Red-Black Tree"
        ],
        "correct_index": 1,
        "explanation": "B-Trees (e suas variaÃ§Ãµes como B+Trees) sÃ£o eficientes para buscas de valores exatos e varreduras de intervalo (range scans), sendo a estrutura padrÃ£o para Ã­ndices devido ao seu balanceamento e performance logarÃ­tmica. ðŸŒ³"
    },
    {
        "chapter": 1,
        "question": "O que um 'nÃ³ folha' (leaf node) em um Ã­ndice B-Tree normalmente contÃ©m, alÃ©m do valor da chave indexada?",
        "options": [
            "A) Apenas ponteiros para outros nÃ³s folha.",
            "B) Um ponteiro para a linha de dados real na tabela (ex: ROWID) e, em B+Trees, ponteiros para os nÃ³s folha vizinhos.",
            "C) Uma cÃ³pia completa de todas as outras colunas da tabela.",
            "D) Metadados sobre a estrutura da B-Tree."
        ],
        "correct_index": 1,
        "explanation": "Os nÃ³s folha de um Ã­ndice B-Tree (especialmente B+Tree) contÃªm os valores das chaves indexadas, um ponteiro (como ROWID) para a localizaÃ§Ã£o da linha completa na tabela (heap table) e ponteiros para os nÃ³s folha adjacentes para facilitar varreduras de intervalo. ðŸƒ"
    },
    {
        "chapter": 1,
        "question": "O que significa o termo 'SARGable' (Search Argument Able) em relaÃ§Ã£o a um predicado na clÃ¡usula WHERE?",
        "options": [
            "A) Um predicado que sÃ³ pode ser usado com argumentos do tipo string.",
            "B) Um predicado que Ã© muito complexo para o otimizador entender.",
            "C) Um predicado que estÃ¡ formulado de tal maneira que o banco de dados pode usar um Ã­ndice para satisfazÃª-lo eficientemente.",
            "D) Um predicado que garante um 'Index-Only Scan'."
        ],
        "correct_index": 2,
        "explanation": "Um predicado SARGable (Search ARGument Able) permite que o mecanismo de busca do banco de dados use um Ã­ndice para restringir o conjunto de linhas a serem examinadas, em vez de fazer um table scan. ðŸ‘"
    },
    {
        "chapter": 1,
        "question": "Qual das seguintes condiÃ§Ãµes na clÃ¡usula WHERE Ã© MENOS provÃ¡vel de ser SARGable e, portanto, impedir o uso eficiente de um Ã­ndice padrÃ£o na coluna `data_evento`?",
        "options": [
            "A) `WHERE data_evento = '2024-01-15'`",
            "B) `WHERE data_evento BETWEEN '2024-01-01' AND '2024-01-31'`",
            "C) `WHERE TO_CHAR(data_evento, 'YYYY') = '2024'`",
            "D) `WHERE data_evento > '2024-01-01'`"
        ],
        "correct_index": 2,
        "explanation": "Aplicar uma funÃ§Ã£o (como TO_CHAR) a uma coluna indexada no lado esquerdo do predicado geralmente torna o predicado non-SARGable para um Ã­ndice padrÃ£o nessa coluna, pois o banco teria que calcular a funÃ§Ã£o para cada linha antes de comparar. FUNC(coluna) = valor ðŸš«"
    },
    {
        "chapter": 1,
        "question": "O que Ã© um 'Table Access by Index ROWID' (ou equivalente) no plano de execuÃ§Ã£o de uma consulta?",
        "options": [
            "A) Uma operaÃ§Ã£o que indica que a consulta foi totalmente satisfeita pelo Ã­ndice (Index-Only Scan).",
            "B) Uma operaÃ§Ã£o onde o banco de dados usa o ROWID (ou ponteiro similar) obtido de uma varredura de Ã­ndice para localizar e buscar a linha completa na tabela principal.",
            "C) Um erro que ocorre quando o ROWID nÃ£o Ã© encontrado.",
            "D) Uma operaÃ§Ã£o que sempre Ã© mais rÃ¡pida que um Full Table Scan."
        ],
        "correct_index": 1,
        "explanation": "ApÃ³s encontrar uma entrada de chave em um Ã­ndice, se a consulta precisa de colunas nÃ£o presentes no Ã­ndice, o banco de dados usa o ponteiro (ROWID) para acessar a tabela principal e buscar o restante dos dados da linha. ðŸ”"
    },
    {
        "chapter": 1,
        "question": "Qual o principal benefÃ­cio de um Ã­ndice em termos de performance de `SELECT`?",
        "options": [
            "A) Reduzir o espaÃ§o em disco usado pela tabela.",
            "B) Acelerar operaÃ§Ãµes de `INSERT` e `UPDATE`.",
            "C) Reduzir o nÃºmero de blocos de dados que precisam ser lidos do disco para satisfazer uma consulta.",
            "D) Garantir a atomicidade das transaÃ§Ãµes."
        ],
        "correct_index": 2,
        "explanation": "Os Ã­ndices permitem que o banco de dados localize rapidamente as linhas que correspondem aos critÃ©rios de uma consulta sem ter que varrer a tabela inteira, reduzindo significativamente o I/O de disco e o tempo de resposta. ðŸ’¾âž¡ï¸âš¡"
    },
    {
        "chapter": 1,
        "question": "Se uma consulta `SELECT col1, col2 FROM tabela WHERE col3 = 100` Ã© executada, e existe um Ã­ndice apenas na `col3`, qual Ã© um resultado provÃ¡vel no plano de execuÃ§Ã£o se `col1` e `col2` nÃ£o estiverem nesse Ã­ndice?",
        "options": [
            "A) Full Table Scan, porque `col1` e `col2` nÃ£o estÃ£o no Ã­ndice.",
            "B) Index Scan em `col3` seguido de Table Access by ROWID para buscar `col1` e `col2`.",
            "C) Index-Only Scan, pois a condiÃ§Ã£o `WHERE` usa um Ã­ndice.",
            "D) O banco criarÃ¡ um Ã­ndice temporÃ¡rio em `col1` e `col2`."
        ],
        "correct_index": 1,
        "explanation": "O Ã­ndice em `col3` serÃ¡ usado para encontrar as linhas relevantes (Index Scan). Como `col1` e `col2` nÃ£o estÃ£o nesse Ã­ndice, o banco precisarÃ¡ acessar a tabela principal (Table Access) para obter esses valores para as linhas encontradas. ðŸŽ¯"
    },
    {
        "chapter": 1,
        "question": "O que Ã© 'seletividade' (selectivity) de um valor em uma coluna indexada?",
        "options": [
            "A) A capacidade de um Ã­ndice selecionar todas as colunas da tabela.",
            "B) Uma medida de quÃ£o poucas linhas um valor especÃ­fico da coluna indexada retorna; alta seletividade significa que o valor Ã© raro e retorna poucas linhas.",
            "C) A garantia de que a consulta `SELECT` usarÃ¡ o Ã­ndice, independentemente do valor.",
            "D) O nÃºmero de colunas incluÃ­das em um Ã­ndice."
        ],
        "correct_index": 1,
        "explanation": "Alta seletividade (um valor que aparece em poucas linhas) torna o Ã­ndice muito eficaz para esse valor, pois ele restringe drasticamente o conjunto de resultados. Baixa seletividade (um valor que aparece em muitas linhas) torna o Ã­ndice menos Ãºtil para esse valor especÃ­fico. ðŸ“Š"
    },
    {
        "chapter": 1,
        "question": "A profundidade de uma B-Tree (nÃºmero de nÃ­veis do topo Ã  folha) geralmente cresce de que forma em relaÃ§Ã£o ao nÃºmero de linhas na tabela?",
        "options": [
            "A) Linearmente (ex: dobrar as linhas dobra a profundidade).",
            "B) Exponencialmente (ex: dobrar as linhas quadruplica a profundidade).",
            "C) Logaritmicamente (ex: a profundidade cresce muito lentamente, mesmo com um grande aumento de linhas).",
            "D) Permanece constante apÃ³s a B-Tree atingir 3 nÃ­veis."
        ],
        "correct_index": 2,
        "explanation": "A profundidade de uma B-Tree cresce logaritmicamente com o nÃºmero de entradas. Isso Ã© fundamental para sua eficiÃªncia, pois mesmo para tabelas com milhÃµes ou bilhÃµes de linhas, a profundidade do Ã­ndice permanece pequena (geralmente 3 a 5 nÃ­veis), garantindo buscas rÃ¡pidas. ðŸ¢âž¡ï¸ðŸ‡"
    },
    {
        "chapter": 1,
        "question": "Considerando um Ã­ndice na coluna `status_pedido` (que pode ter valores como 'PENDENTE', 'PAGO', 'ENVIADO', 'CANCELADO'), qual tipo de consulta se beneficiaria MENOS desse Ã­ndice se a distribuiÃ§Ã£o de status for muito desigual (ex: 90% dos pedidos estÃ£o como 'ENVIADO')?",
        "options": [
            "A) `WHERE status_pedido = 'PENDENTE'` (supondo que 'PENDENTE' Ã© raro)",
            "B) `WHERE status_pedido = 'ENVIADO'` (supondo que 'ENVIADO' Ã© muito comum)",
            "C) `WHERE status_pedido IN ('PENDENTE', 'PAGO')` (supondo que ambos sÃ£o raros)",
            "D) Todas as consultas se beneficiariam igualmente."
        ],
        "correct_index": 1,
        "explanation": "Um Ã­ndice Ã© menos eficaz (e o otimizador pode atÃ© optar por nÃ£o usÃ¡-lo) para buscar valores de baixa seletividade, ou seja, valores que aparecem em uma grande porcentagem das linhas da tabela. Se 'ENVIADO' Ã© muito comum, buscar por ele pode resultar na leitura de grande parte da tabela de qualquer maneira. ðŸ“‰"
    },
{
        "chapter": 2,
        "question": "Qual Ã© a 'leading edge' (borda principal ou parte inicial) de um Ã­ndice multicoluna, por exemplo, em `(col_A, col_B, col_C)`?",
        "options": [
            "A) Apenas a coluna C, por ser a Ãºltima e mais especÃ­fica.",
            "B) Qualquer combinaÃ§Ã£o das colunas A, B, ou C, em qualquer ordem.",
            "C) A coluna A sozinha, ou o par (col_A, col_B), ou o trio (col_A, col_B, col_C), indicando que as colunas devem ser usadas em ordem a partir da primeira.",
            "D) Apenas a coluna do meio (col_B), para fins de balanceamento do Ã­ndice."
        ],
        "correct_index": 2,
        "explanation": "A 'leading edge' refere-se ao uso da(s) primeira(s) coluna(s) do Ã­ndice, na ordem em que foram definidas. Para o Ã­ndice (A,B,C), a borda principal pode ser A, (A,B) ou (A,B,C). CondiÃ§Ãµes que usam essa borda sÃ£o mais eficientes. ðŸ“"
    },
    {
        "chapter": 2,
        "question": "Se vocÃª tem um Ã­ndice multicoluna em `(sobrenome, primeiro_nome)`, qual das seguintes clÃ¡usulas `WHERE` NÃƒO poderÃ¡ usar este Ã­ndice de forma otimizada para um 'seek' ou 'range scan' eficiente?",
        "options": [
            "A) `WHERE sobrenome = 'Silva' AND primeiro_nome = 'JoÃ£o'`",
            "B) `WHERE sobrenome = 'Silva'`",
            "C) `WHERE primeiro_nome = 'JoÃ£o'`",
            "D) `WHERE sobrenome LIKE 'S%'`"
        ],
        "correct_index": 2,
        "explanation": "Um Ã­ndice multicoluna geralmente requer que a(s) primeira(s) coluna(s) do Ã­ndice (a 'leading edge') sejam usadas na clÃ¡usula WHERE para uma busca eficiente. Consultar apenas por `primeiro_nome` 'pula' a primeira coluna do Ã­ndice (`sobrenome`), tornando o uso do Ã­ndice menos eficiente ou impossÃ­vel para um seek direto. ðŸ”"
    },
    {
        "chapter": 2,
        "question": "Ao definir a ordem das colunas em um Ã­ndice multicoluna, qual Ã© uma heurÃ­stica comum para otimizar consultas que usam condiÃ§Ãµes de igualdade (`=`) e de intervalo (`>`, `<`, `BETWEEN`)?",
        "options": [
            "A) Sempre colocar as colunas usadas em condiÃ§Ãµes de intervalo primeiro.",
            "B) Colocar as colunas usadas em condiÃ§Ãµes de igualdade primeiro, seguidas pelas colunas usadas em condiÃ§Ãµes de intervalo.",
            "C) A ordem nÃ£o importa se todas as colunas do WHERE estiverem no Ã­ndice.",
            "D) Colocar as colunas com menor seletividade primeiro."
        ],
        "correct_index": 1,
        "explanation": "Para mÃ¡xima eficiÃªncia, as colunas usadas com predicados de igualdade devem vir primeiro no Ã­ndice. A primeira coluna com uma condiÃ§Ã£o de intervalo pode usar o Ã­ndice para um range scan, mas as colunas subsequentes no Ã­ndice geralmente sÃ³ servirÃ£o para filtragem adicional, nÃ£o para restringir o range inicial. (=, =, >) âœ…"
    },
    {
        "chapter": 2,
        "question": "Um 'Index-Only Scan' Ã© possÃ­vel com um Ã­ndice multicoluna em `(col_A, col_B, col_C)` se a consulta for `SELECT col_A, col_B FROM tabela WHERE col_A = 10 AND col_B > 5`?",
        "options": [
            "A) NÃ£o, pois a coluna C do Ã­ndice nÃ£o estÃ¡ no SELECT nem no WHERE.",
            "B) Sim, porque todas as colunas necessÃ¡rias para o SELECT (`col_A`, `col_B`) e para o WHERE (`col_A`, `col_B`) estÃ£o presentes no Ã­ndice.",
            "C) Apenas se `col_A` e `col_B` juntas formarem uma chave primÃ¡ria.",
            "D) NÃ£o, Index-Only Scans sÃ³ funcionam com Ã­ndices de coluna Ãºnica."
        ],
        "correct_index": 1,
        "explanation": "Um Index-Only Scan Ã© possÃ­vel se todas as colunas referenciadas em todas as partes da consulta (SELECT, WHERE, ORDER BY, GROUP BY) estiverem contidas no Ã­ndice. Neste caso, `col_A` e `col_B` estÃ£o no Ã­ndice. ðŸ’¯"
    },
    {
        "chapter": 2,
        "question": "Se uma consulta tem `WHERE col_A > 10 AND col_B = 5` e existe um Ã­ndice multicoluna em `(col_A, col_B)`, como o banco de dados provavelmente usarÃ¡ o Ã­ndice?",
        "options": [
            "A) O Ã­ndice nÃ£o pode ser usado porque a primeira coluna (`col_A`) tem uma condiÃ§Ã£o de intervalo e a segunda (`col_B`) tem uma condiÃ§Ã£o de igualdade.",
            "B) Apenas a condiÃ§Ã£o `col_B = 5` serÃ¡ usada para um 'index seek', e `col_A > 10` serÃ¡ um filtro residual.",
            "C) O Ã­ndice serÃ¡ usado para um 'range scan' em `col_A` (para `col_A > 10`), e a condiÃ§Ã£o `col_B = 5` serÃ¡ aplicada como um predicado de filtro nas entradas do Ã­ndice encontradas.",
            "D) O banco farÃ¡ duas varreduras de Ã­ndice separadas e depois juntarÃ¡ os resultados."
        ],
        "correct_index": 2,
        "explanation": "O banco pode fazer um range scan no Ã­ndice para `col_A > 10`. Para as entradas do Ã­ndice que satisfazem essa condiÃ§Ã£o, ele entÃ£o verifica se `col_B = 5`. A coluna `col_B` nÃ£o pode ser usada para um 'seek' inicial apÃ³s uma condiÃ§Ã£o de range em `col_A`. (>)"
    },
    {
        "chapter": 2,
        "question": "Considerando a consulta `SELECT * FROM pedidos WHERE cliente_id = ? AND status_pedido = ?`, qual Ã­ndice seria geralmente mais benÃ©fico se `cliente_id` for muito mais seletivo que `status_pedido`?",
        "options": [
            "A) Um Ã­ndice em `(status_pedido, cliente_id)`.",
            "B) Um Ã­ndice em `(cliente_id, status_pedido)`.",
            "C) Dois Ã­ndices separados: um em `cliente_id` e outro em `status_pedido`.",
            "D) Nenhum Ã­ndice Ã© necessÃ¡rio se a tabela for pequena."
        ],
        "correct_index": 1,
        "explanation": "Colocar a coluna mais seletiva (`cliente_id`) primeiro no Ã­ndice multicoluna permite que o banco reduza o conjunto de linhas candidatas mais rapidamente. O filtro por `status_pedido` Ã© entÃ£o aplicado a um conjunto menor. ðŸŽ¯"
    },
    {
        "chapter": 2,
        "question": "Quando um Ã­ndice em `(A, B)` Ã© mais vantajoso do que ter dois Ã­ndices separados, um em `A` e outro em `B`?",
        "options": [
            "A) Sempre, pois ocupa menos espaÃ§o.",
            "B) Principalmente quando as consultas frequentemente filtram por `A` e `B` juntos (ex: `WHERE A = ? AND B = ?`) ou quando um Index-Only Scan pode ser satisfeito pelo Ã­ndice `(A, B)`.",
            "C) Apenas se a coluna `B` for uma chave estrangeira para `A`.",
            "D) Ter dois Ã­ndices separados Ã© sempre preferÃ­vel para flexibilidade."
        ],
        "correct_index": 1,
        "explanation": "Um Ã­ndice concatenado `(A, B)` Ã© otimizado para consultas que usam a 'leading edge' (A, ou A e B). Ele tambÃ©m pode cobrir consultas que selecionam A e B. Dois Ã­ndices separados nÃ£o oferecem a mesma ordenaÃ§Ã£o combinada e podem exigir que o banco combine os resultados dos dois Ã­ndices, o que pode ser menos eficiente. ðŸ¤"
    },
    {
        "chapter": 2,
        "question": "Em um Ã­ndice `(regiao, cidade, bairro)`, uma consulta com `WHERE regiao = 'SUDESTE' AND bairro = 'CENTRO'` pode usar eficientemente todas as partes do Ã­ndice para um 'seek' direto?",
        "options": [
            "A) Sim, o otimizador pode usar as colunas do Ã­ndice em qualquer ordem.",
            "B) NÃ£o, porque a coluna `cidade` foi 'pulada' na condiÃ§Ã£o WHERE, quebrando a 'leading edge' do Ã­ndice apÃ³s `regiao`.",
            "C) Sim, desde que `bairro` seja uma coluna altamente seletiva.",
            "D) Apenas se `regiao`, `cidade`, e `bairro` forem todas do tipo VARCHAR."
        ],
        "correct_index": 1,
        "explanation": "Para que um Ã­ndice multicoluna seja usado eficientemente em todas as suas partes para um 'seek' ou 'range scan' preciso, as condiÃ§Ãµes na clÃ¡usula `WHERE` devem corresponder a um prefixo contÃ­nuo das colunas do Ã­ndice. Pular uma coluna intermediÃ¡ria (`cidade` neste caso) impede o uso otimizado das colunas subsequentes (`bairro`) para refinar o 'seek' inicial. ðŸš§"
    },
    {
        "chapter": 2,
        "question": "Se um Ã­ndice multicoluna Ã© `(data_pedido, cliente_id, status)` e a consulta Ã© `SELECT ... FROM pedidos WHERE cliente_id = 123 ORDER BY data_pedido`, o Ã­ndice pode ser usado para a clÃ¡usula `ORDER BY`?",
        "options": [
            "A) Sim, diretamente, pois `data_pedido` estÃ¡ no Ã­ndice.",
            "B) NÃ£o, porque `data_pedido` nÃ£o Ã© a primeira coluna do Ã­ndice e a clÃ¡usula `WHERE` nÃ£o a utiliza para restringir o range de forma a garantir a ordem por `data_pedido` para o `cliente_id` especÃ­fico.",
            "C) Sim, mas apenas se `cliente_id` for a chave primÃ¡ria.",
            "D) Apenas se a consulta tambÃ©m incluir `WHERE data_pedido > 'alguma_data'`."
        ],
        "correct_index": 1,
        "explanation": "Para que um Ã­ndice multicoluna satisfaÃ§a um `ORDER BY`, as colunas do `ORDER BY` devem corresponder a um prefixo do Ã­ndice, e as colunas anteriores a elas no Ã­ndice devem ter condiÃ§Ãµes de igualdade no `WHERE`. Aqui, `cliente_id` Ã© filtrado, mas nÃ£o hÃ¡ garantia de que os resultados para esse cliente estarÃ£o ordenados por `data_pedido` sem um sort adicional, pois `data_pedido` nÃ£o Ã© a primeira coluna usada pelo `WHERE` de forma a manter sua ordem natural para o subconjunto filtrado. âš ï¸"
    },
    {
        "chapter": 2,
        "question": "Qual afirmaÃ§Ã£o sobre Ã­ndices multicoluna Ã© geralmente VERDADEIRA?",
        "options": [
            "A) Adicionar mais colunas a um Ã­ndice sempre melhora a performance de todas as consultas.",
            "B) A ordem das colunas em um Ã­ndice multicoluna nÃ£o afeta como ele Ã© utilizado pelo otimizador.",
            "C) Um Ã­ndice multicoluna pode ser usado para satisfazer uma consulta mesmo que apenas a segunda ou terceira coluna do Ã­ndice seja referenciada no WHERE, desde que com igualdade.",
            "D) A eficÃ¡cia de um Ã­ndice multicoluna depende crucialmente da ordem das suas colunas e de como as clÃ¡usulas WHERE e ORDER BY interagem com essa ordem."
        ],
        "correct_index": 3,
        "explanation": "A ordem das colunas Ã© fundamental. A 'leading edge' do Ã­ndice deve ser utilizada pela clÃ¡usula WHERE para que o Ã­ndice seja eficaz. Adicionar colunas desnecessÃ¡rias pode aumentar o tamanho do Ã­ndice e o custo de manutenÃ§Ã£o. Usar colunas do meio sem as primeiras nÃ£o Ã© eficiente. ðŸ§"
    },
{
        "chapter": 3,
        "question": "Qual das seguintes consultas com o operador `LIKE` tem maior probabilidade de utilizar um Ã­ndice padrÃ£o na coluna `nome_produto` de forma eficiente?",
        "options": [
            "A) `WHERE nome_produto LIKE '%Caneta%'` (curinga no inÃ­cio e no fim)",
            "B) `WHERE nome_produto LIKE 'Caneta%'` (curinga apenas no fim)",
            "C) `WHERE nome_produto LIKE '%Azul'` (curinga apenas no inÃ­cio)",
            "D) Todas as opÃ§Ãµes acima usarÃ£o o Ã­ndice da mesma forma."
        ],
        "correct_index": 1,
        "explanation": "Um `LIKE` com um curinga (`%` ou `_`) no inÃ­cio de um padrÃ£o (`'%Termo'` ou `'%Termo%'`) geralmente impede o uso de um Ã­ndice B-Tree padrÃ£o para um 'seek' ou 'range scan' eficiente. `LIKE 'Termo%'` pode usar o Ã­ndice porque o prefixo Ã© conhecido. ðŸ”Ž"
    },
    {
        "chapter": 3,
        "question": "O que Ã© um 'Function-Based Index' (Ãndice Baseado em FunÃ§Ã£o) ou 'Index on Expression' (Ãndice em ExpressÃ£o)?",
        "options": [
            "A) Um Ã­ndice que sÃ³ pode ser usado dentro de Stored Procedures ou FunÃ§Ãµes do banco de dados.",
            "B) Um Ã­ndice que armazena o resultado de uma funÃ§Ã£o ou expressÃ£o aplicada a uma ou mais colunas, em vez de armazenar os valores diretos das colunas.",
            "C) Um tipo especial de Ã­ndice que automaticamente aplica funÃ§Ãµes comuns (como `UPPER`, `LOWER`) a todas as colunas de texto da tabela.",
            "D) Um Ã­ndice que permite buscas `LIKE` com curinga no inÃ­cio de forma eficiente em qualquer SGBD."
        ],
        "correct_index": 1,
        "explanation": "Um Ã­ndice baseado em funÃ§Ã£o prÃ©-calcula e armazena os resultados de uma expressÃ£o (ex: `UPPER(coluna)`). Se a clÃ¡usula `WHERE` usar exatamente a mesma expressÃ£o (ex: `WHERE UPPER(coluna) = 'VALOR'`), o banco pode usar esse Ã­ndice eficientemente.  Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¸Ð½Ð´ÐµÐºÑ âœ…"
    },
    {
        "chapter": 3,
        "question": "Considere a consulta `SELECT * FROM usuarios WHERE UPPER(email) = 'USUARIO@EMAIL.COM'`. Qual Ã© a melhor abordagem para otimizar esta consulta se ela for frequente?",
        "options": [
            "A) Criar um Ã­ndice padrÃ£o na coluna `email` e esperar que o SGBD o utilize.",
            "B) Evitar o uso da funÃ§Ã£o `UPPER` e garantir que os dados no `WHERE` correspondam ao case da coluna `email`.",
            "C) Criar um Ã­ndice baseado na funÃ§Ã£o `UPPER(email)`.",
            "D) Usar `email LIKE 'usuario@email.com'` com a opÃ§Ã£o `COLLATE` para ignorar case."
        ],
        "correct_index": 2,
        "explanation": "Para que uma funÃ§Ã£o aplicada a uma coluna na clÃ¡usula `WHERE` possa usar um Ã­ndice diretamente, o Ã­ndice deve ser criado sobre essa mesma expressÃ£o funcional. Um Ã­ndice em `UPPER(email)` atenderia perfeitamente Ã  condiÃ§Ã£o. ðŸ› ï¸"
    },
    {
        "chapter": 3,
        "question": "Por que a consulta `WHERE nome_coluna LIKE '%meio%'` Ã© geralmente ineficiente, mesmo que `nome_coluna` esteja indexada?",
        "options": [
            "A) Porque o curinga `%` nÃ£o Ã© um caractere SQL padrÃ£o.",
            "B) Porque o banco de dados nÃ£o consegue usar a estrutura ordenada de um Ã­ndice B-Tree para localizar diretamente um padrÃ£o que pode comeÃ§ar em qualquer lugar da string.",
            "C) Porque `LIKE` sempre resulta em um Full Table Scan, independentemente dos curingas.",
            "D) Porque esse tipo de `LIKE` sÃ³ funciona bem com Full-Text Search Indexes."
        ],
        "correct_index": 1,
        "explanation": "Ãndices B-Tree sÃ£o como dicionÃ¡rios ordenados. Se vocÃª nÃ£o sabe a primeira letra (ou primeiras letras) da palavra que procura (que Ã© o caso de `'%meio%'`), o dicionÃ¡rio ordenado nÃ£o ajuda muito a encontrÃ¡-la rapidamente. ðŸ“–"
    },
    {
        "chapter": 3,
        "question": "Qual a principal desvantagem de usar Ã­ndices baseados em funÃ§Ã£o?",
        "options": [
            "A) Eles sÃ£o sempre muito maiores que Ã­ndices normais.",
            "B) Eles sÃ³ podem ser usados em colunas do tipo numÃ©rico.",
            "C) A consulta deve usar *exatamente* a mesma funÃ§Ã£o/expressÃ£o que foi usada na definiÃ§Ã£o do Ã­ndice para que ele seja utilizado.",
            "D) Eles impedem qualquer operaÃ§Ã£o de `INSERT` ou `UPDATE` na tabela."
        ],
        "correct_index": 2,
        "explanation": "Para que um Ã­ndice baseado em funÃ§Ã£o seja aproveitado, a expressÃ£o na clÃ¡usula `WHERE` da consulta deve corresponder precisamente Ã  expressÃ£o usada para criar o Ã­ndice. Pequenas variaÃ§Ãµes podem fazer com que o otimizador nÃ£o o utilize. ðŸŽ¯"
    },
    {
        "chapter": 3,
        "question": "Para buscas case-insensitive (sem diferenciar maiÃºsculas de minÃºsculas) em uma coluna de texto, qual das seguintes NÃƒO Ã© uma tÃ©cnica comum de otimizaÃ§Ã£o mencionada ou implÃ­cita no contexto do livro?",
        "options": [
            "A) Usar a funÃ§Ã£o `LOWER()` ou `UPPER()` em ambos os lados da comparaÃ§Ã£o e ter um Ã­ndice na funÃ§Ã£o aplicada Ã  coluna (ex: `INDEX ON (LOWER(coluna))`).",
            "B) Usar um `COLLATE` especÃ­fico no nÃ­vel da coluna ou da consulta que seja case-insensitive (se o SGBD suportar e o Ã­ndice for compatÃ­vel).",
            "C) Armazenar uma versÃ£o normalizada da coluna (ex: toda em minÃºsculas) em uma coluna separada e indexar essa nova coluna.",
            "D) Aplicar a funÃ§Ã£o `LOWER()` ou `UPPER()` apenas no valor fornecido pelo usuÃ¡rio no `WHERE`, deixando a coluna do banco intacta, para usar o Ã­ndice padrÃ£o."
        ],
        "correct_index": 3,
        "explanation": "Aplicar a funÃ§Ã£o apenas no valor do usuÃ¡rio (`WHERE coluna = LOWER('VALOR')`) nÃ£o torna a busca na coluna do banco SARGable para um Ã­ndice padrÃ£o. A funÃ§Ã£o precisa estar na coluna do banco no `WHERE` para usar um Ã­ndice funcional, ou o `COLLATE` deve cuidar disso, ou uma coluna normalizada deve ser usada. Aa â‰  aA"
    },
    {
        "chapter": 3,
        "question": "Qual das alternativas descreve melhor o comportamento do otimizador de consultas quando encontra uma funÃ§Ã£o aplicada a uma coluna em um predicado `WHERE` (ex: `WHERE ANO(data_nascimento) = 2000`) e nÃ£o hÃ¡ um Ã­ndice baseado nessa funÃ§Ã£o?",
        "options": [
            "A) O otimizador tentarÃ¡ reescrever a consulta para remover a funÃ§Ã£o automaticamente.",
            "B) O otimizador calcularÃ¡ a funÃ§Ã£o para cada linha da tabela e entÃ£o compararÃ¡ o resultado, resultando frequentemente em um Full Table Scan ou Index Full Scan.",
            "C) O otimizador retornarÃ¡ um erro, pois funÃ§Ãµes em predicados sÃ£o proibidas.",
            "D) O otimizador usarÃ¡ um Ã­ndice padrÃ£o na coluna `data_nascimento` e aplicarÃ¡ a funÃ§Ã£o `ANO()` apenas aos valores lidos do Ã­ndice."
        ],
        "correct_index": 1,
        "explanation": "Sem um Ã­ndice na expressÃ£o `ANO(data_nascimento)`, o banco de dados geralmente precisa aplicar a funÃ§Ã£o `ANO()` a cada valor da coluna `data_nascimento` na tabela (ou em todas as entradas de um Ã­ndice, se fizer um Index Full Scan) antes de poder comparar com `2000`. Isso impede um 'seek' direto. ðŸ¢"
    },
    {
        "chapter": 3,
        "question": "Se vocÃª precisa frequentemente buscar por `SUBSTRING(codigo_produto, 1, 3) = 'ABC'`, qual seria a forma mais eficiente de indexar para essa consulta?",
        "options": [
            "A) Um Ã­ndice na coluna `codigo_produto` inteira.",
            "B) Um Ã­ndice baseado na funÃ§Ã£o `SUBSTRING(codigo_produto, 1, 3)`.",
            "C) NÃ£o indexar e confiar no cache do banco.",
            "D) Um Ã­ndice em outra coluna nÃ£o relacionada."
        ],
        "correct_index": 1,
        "explanation": "Criar um Ã­ndice sobre a expressÃ£o exata usada na consulta (`SUBSTRING(codigo_produto, 1, 3)`) permite que o banco utilize esse Ã­ndice diretamente para encontrar as linhas correspondentes. âœ‚ï¸"
    },
    {
        "chapter": 3,
        "question": "O uso de `OR` em uma clÃ¡usula `WHERE` combinando condiÃ§Ãµes em colunas diferentes (ex: `WHERE status = 'A' OR prioridade = 1`) pode, Ã s vezes, dificultar a otimizaÃ§Ã£o com Ã­ndices padrÃµes. Qual Ã© uma alternativa que o livro pode sugerir para reescrever tal consulta, se aplicÃ¡vel e se as condiÃ§Ãµes forem independentes?",
        "options": [
            "A) Sempre usar `AND` em vez de `OR`.",
            "B) Usar `UNION ALL` para combinar os resultados de duas consultas separadas, cada uma otimizada para uma das condiÃ§Ãµes do `OR` (assumindo que cada condiÃ§Ã£o pode usar um Ã­ndice diferente).",
            "C) Remover a clÃ¡usula `WHERE` e filtrar na aplicaÃ§Ã£o.",
            "D) Criar um Ã­ndice multicoluna em `(status, prioridade)`."
        ],
        "correct_index": 1,
        "explanation": "Para `OR` em colunas diferentes, onde cada condiÃ§Ã£o pode usar um Ã­ndice diferente, reescrever com `UNION ALL` (e depois talvez `DISTINCT` se necessÃ¡rio) pode permitir que cada parte da uniÃ£o use seu prÃ³prio Ã­ndice otimizado. Um Ã­ndice em `(status, prioridade)` nÃ£o ajudaria muito um `OR` simples. âˆª"
    },
    {
        "chapter": 3,
        "question": "Qual Ã© o impacto principal de um predicado `WHERE data_coluna + INTERVAL '1 day' > CURRENT_DATE` em relaÃ§Ã£o ao uso de um Ã­ndice na `data_coluna`?",
        "options": [
            "A) Nenhum impacto, o Ã­ndice serÃ¡ usado normalmente.",
            "B) O Ã­ndice nÃ£o pode ser usado porque hÃ¡ uma operaÃ§Ã£o aritmÃ©tica (`+ INTERVAL '1 day'`) na coluna indexada.",
            "C) O Ã­ndice serÃ¡ usado, mas de forma menos eficiente.",
            "D) O banco de dados criarÃ¡ um Ã­ndice temporÃ¡rio na expressÃ£o."
        ],
        "correct_index": 1,
        "explanation": "Aplicar aritmÃ©tica ou funÃ§Ãµes a uma coluna no predicado `WHERE` geralmente torna o predicado non-SARGable para um Ã­ndice padrÃ£o nessa coluna. Seria melhor reescrever como `data_coluna > CURRENT_DATE - INTERVAL '1 day'` para manter a coluna isolada. ðŸ—“ï¸"
    },
{
        "chapter": 4,
        "question": "Qual dos seguintes algoritmos de JOIN Ã© geralmente o mais eficiente quando uma tabela (a 'externa') Ã© pequena e a outra (a 'interna') Ã© grande e possui um Ã­ndice na(s) coluna(s) de junÃ§Ã£o?",
        "options": [
            "A) Hash Join",
            "B) Sort Merge Join",
            "C) Nested Loops Join",
            "D) Cartesian Product (Cross Join)"
        ],
        "correct_index": 2,
        "explanation": "O Nested Loops Join itera sobre as linhas da tabela externa (menor) e, para cada uma, usa o Ã­ndice da tabela interna (maior) para encontrar as linhas correspondentes rapidamente. âž°"
    },
    {
        "chapter": 4,
        "question": "Em um `SELECT t1.*, t2.* FROM tabela1 t1 JOIN tabela2 t2 ON t1.id_fk = t2.id_pk`, qual coluna Ã© a candidata mais importante para ter um Ã­ndice visando otimizar um Nested Loops Join?",
        "options": [
            "A) `t1.id_fk` (a coluna da chave estrangeira na tabela 'externa' da junÃ§Ã£o)",
            "B) `t2.id_pk` (a coluna da chave primÃ¡ria na tabela 'interna' da junÃ§Ã£o, que jÃ¡ Ã© indexada)",
            "C) Uma coluna nÃ£o relacionada ao JOIN em `tabela1`.",
            "D) Uma coluna nÃ£o relacionada ao JOIN em `tabela2`."
        ],
        "correct_index": 0,
        "explanation": "Para o Nested Loops Join, Ã© crucial que a coluna da tabela 'interna' na condiÃ§Ã£o de junÃ§Ã£o seja indexada. Se `tabela1` for a tabela externa e `tabela2` a interna, um Ã­ndice em `t2.id_pk` (que jÃ¡ existe) Ã© usado. Se `tabela2` for a externa e `tabela1` a interna, um Ã­ndice em `t1.id_fk` seria essencial. No contexto da pergunta, o acesso eficiente Ã  tabela 'interna' (a segunda na ordem do loop) Ã© chave; se `t1` Ã© a externa, o Ã­ndice em `t2.id_pk` (PK) Ã© usado. Se a ordem for invertida pelo otimizador, um Ã­ndice em `t1.id_fk` seria vital. A pergunta sugere `t1 JOIN t2`, entÃ£o `t2.id_pk` Ã© chave para o acesso Ã  `t2` (interna) para cada linha de `t1` (externa)."
    },
    {
        "chapter": 4,
        "question": "Quando um 'Hash Join' Ã© frequentemente escolhido pelo otimizador do banco de dados?",
        "options": [
            "A) Apenas quando ambas as tabelas envolvidas no JOIN sÃ£o muito pequenas.",
            "B) Para junÃ§Ãµes de igualdade (`=`), especialmente quando os conjuntos de dados sÃ£o grandes e nÃ£o hÃ¡ Ã­ndices adequados para um Nested Loops Join, ou quando o otimizador estima que serÃ¡ mais rÃ¡pido.",
            "C) Para junÃ§Ãµes que envolvem condiÃ§Ãµes de intervalo (`>`, `<`), pois o hash Ã© bom para ranges.",
            "D) Somente se as colunas de junÃ§Ã£o forem do tipo numÃ©rico inteiro."
        ],
        "correct_index": 1,
        "explanation": "O Hash Join constrÃ³i uma tabela hash de uma das tabelas (geralmente a menor) na memÃ³ria e depois varre a outra tabela, procurando correspondÃªncias na tabela hash. Ã‰ eficiente para junÃ§Ãµes de igualdade em grandes volumes de dados e quando os Ã­ndices nÃ£o favorecem outros mÃ©todos. ðŸ—ï¸"
    },
    {
        "chapter": 4,
        "question": "Qual Ã© a principal caracterÃ­stica de um 'Sort Merge Join'?",
        "options": [
            "A) Ele sempre requer que uma das tabelas caiba inteiramente na memÃ³ria.",
            "B) Ele primeiro ordena ambas as tabelas (ou os subconjuntos relevantes) pelas colunas de junÃ§Ã£o e depois mescla (merge) as linhas ordenadas.",
            "C) Ele nÃ£o precisa de condiÃ§Ãµes de igualdade e funciona melhor com `LIKE`.",
            "D) Ele sÃ³ funciona se as colunas de junÃ§Ã£o jÃ¡ forem chaves primÃ¡rias ordenadas."
        ],
        "correct_index": 1,
        "explanation": "O Sort Merge Join, como o nome sugere, envolve duas etapas principais: ordenar as tabelas pela(s) coluna(s) de junÃ§Ã£o (se jÃ¡ nÃ£o estiverem ordenadas por um Ã­ndice) e depois fazer uma passagem linear pelas tabelas ordenadas para encontrar as correspondÃªncias. ðŸ“œ+ðŸ“œ=ðŸ¤"
    },
    {
        "chapter": 4,
        "question": "O que acontece se vocÃª fizer um JOIN entre duas tabelas sem uma clÃ¡usula `ON` (ou com uma condiÃ§Ã£o `ON` que Ã© sempre verdadeira, como `1=1`)?",
        "options": [
            "A) O banco de dados retorna um erro de sintaxe.",
            "B) O banco de dados otimiza e assume uma junÃ§Ã£o pela chave primÃ¡ria e estrangeira mais Ã³bvia.",
            "C) Ocorre um 'Produto Cartesiano' (Cross Join), onde cada linha da primeira tabela Ã© combinada com cada linha da segunda tabela, geralmente resultando em um conjunto de resultados muito grande e raramente desejado.",
            "D) O banco de dados realiza um `INNER JOIN` usando a primeira coluna de cada tabela."
        ],
        "correct_index": 2,
        "explanation": "A ausÃªncia de uma condiÃ§Ã£o de junÃ§Ã£o significativa (ou uma condiÃ§Ã£o sempre verdadeira) resulta em um Produto Cartesiano, que combina todas as linhas de uma tabela com todas as linhas da outra. Cuidado! ðŸ¤¯"
    },
    {
        "chapter": 4,
        "question": "Em um `LEFT OUTER JOIN` de `TabelaA LEFT JOIN TabelaB ON TabelaA.id = TabelaB.fk_a`, o que acontece com as linhas da `TabelaA` que nÃ£o tÃªm correspondÃªncia na `TabelaB`?",
        "options": [
            "A) Elas sÃ£o completamente omitidas do resultado.",
            "B) Elas sÃ£o incluÃ­das no resultado, e as colunas correspondentes da `TabelaB` sÃ£o preenchidas com valores `NULL`.",
            "C) A consulta resulta em um erro, pois todas as linhas da `TabelaA` devem ter correspondÃªncia.",
            "D) Elas sÃ£o incluÃ­das, e as colunas da `TabelaB` sÃ£o preenchidas com valores padrÃ£o da `TabelaB`."
        ],
        "correct_index": 1,
        "explanation": "A caracterÃ­stica do `LEFT OUTER JOIN` Ã© que todas as linhas da tabela da esquerda (`TabelaA`) sÃ£o incluÃ­das no resultado. Se nÃ£o houver correspondÃªncia na tabela da direita (`TabelaB`), as colunas de `TabelaB` sÃ£o preenchidas com `NULL` para essas linhas. â¬…ï¸âœ”ï¸"
    },
    {
        "chapter": 4,
        "question": "Qual a principal recomendaÃ§Ã£o do livro para a ordem das tabelas em um `JOIN` manual (se o SGBD nÃ£o reordenar)?",
        "options": [
            "A) Sempre listar a maior tabela primeiro.",
            "B) A ordem nunca importa, o otimizador sempre corrige.",
            "C) Para Nested Loops, listar a tabela que resulta no menor nÃºmero de iteraÃ§Ãµes no loop externo primeiro (geralmente a tabela menor ou a que retorna menos linhas apÃ³s filtros).",
            "D) Listar as tabelas em ordem alfabÃ©tica para clareza."
        ],
        "correct_index": 2,
        "explanation": "Embora muitos otimizadores tentem reordenar os joins, se vocÃª puder influenciar (ou estiver em um SGBD mais simples), para Nested Loops, ter a tabela menor (ou a que produz menos linhas apÃ³s os filtros iniciais) como a tabela 'externa' do loop Ã© geralmente mais eficiente. ðŸ“"
    },
    {
        "chapter": 4,
        "question": "Usar `SELECT *` em uma consulta com mÃºltiplos `JOIN`s pode ser problemÃ¡tico para a performance por quÃª?",
        "options": [
            "A) Porque `*` Ã© uma palavra reservada que diminui a velocidade do parser SQL.",
            "B) Porque pode impedir 'Index-Only Scans' e aumentar o trÃ¡fego de dados, especialmente se muitas colunas nÃ£o sÃ£o realmente necessÃ¡rias.",
            "C) Porque `SELECT *` nÃ£o Ã© compatÃ­vel com a sintaxe `JOIN`.",
            "D) Porque sempre forÃ§a o uso de um 'Cartesian Product'."
        ],
        "correct_index": 1,
        "explanation": "`SELECT *` busca todas as colunas de todas as tabelas envolvidas. Se algumas dessas colunas nÃ£o sÃ£o necessÃ¡rias e poderiam ser obtidas de um Ã­ndice (ou evitadas), o `SELECT *` forÃ§a o acesso Ã  tabela e aumenta a quantidade de dados transferidos. ðŸŒŸâž¡ï¸ðŸ“¦"
    },
    {
        "chapter": 4,
        "question": "O que Ã© um 'Join Predicate Pushdown'?",
        "options": [
            "A) Uma tÃ©cnica para adiar a avaliaÃ§Ã£o dos predicados de junÃ§Ã£o para o final da consulta.",
            "B) Uma otimizaÃ§Ã£o onde o banco de dados tenta aplicar filtros (predicados `WHERE`) o mais cedo possÃ­vel, idealmente antes ou durante a operaÃ§Ã£o de junÃ§Ã£o, para reduzir o nÃºmero de linhas a serem juntadas.",
            "C) Um tipo de JOIN que sÃ³ funciona com predicados numÃ©ricos.",
            "D) Empurrar manualmente as tabelas na ordem correta na clÃ¡usula FROM."
        ],
        "correct_index": 1,
        "explanation": "Predicate Pushdown Ã© uma otimizaÃ§Ã£o importante onde o SGBD aplica filtros o mais cedo possÃ­vel no plano de execuÃ§Ã£o, muitas vezes 'empurrando-os' para dentro das operaÃ§Ãµes de acesso Ã s tabelas individuais antes mesmo que o join aconteÃ§a, reduzindo o volume de dados a ser processado pelo join. ðŸ”½"
    },
    {
        "chapter": 4,
        "question": "Um `ANTI JOIN` (geralmente implementado com `NOT EXISTS` ou `NOT IN` ou `LEFT JOIN ... WHERE key IS NULL`) Ã© usado para quÃª?",
        "options": [
            "A) Encontrar todas as combinaÃ§Ãµes possÃ­veis entre duas tabelas.",
            "B) Encontrar linhas em uma tabela que NÃƒO tÃªm correspondÃªncia em outra tabela.",
            "C) Juntar uma tabela com ela mesma (Self Join).",
            "D) Somar valores de colunas correspondentes em duas tabelas."
        ],
        "correct_index": 1,
        "explanation": "Um Anti Join Ã© usado para selecionar linhas da primeira tabela para as quais nÃ£o existem linhas correspondentes na segunda tabela, com base na condiÃ§Ã£o de junÃ§Ã£o. ðŸš«ðŸ¤"
    },
    {
        "chapter": 5,
        "question": "Qual Ã© o objetivo principal do 'clustering' (agrupamento) de dados em um banco de dados relacional?",
        "options": [
            "A) Aumentar o nÃºmero de conexÃµes simultÃ¢neas que o banco pode suportar.",
            "B) Reduzir o espaÃ§o total em disco ocupado pela base de dados.",
            "C) Armazenar fisicamente no disco as linhas que sÃ£o frequentemente acessadas juntas o mais prÃ³ximo possÃ­vel umas das outras, para minimizar o I/O.",
            "D) Garantir que todos os Ã­ndices caibam inteiramente na memÃ³ria RAM."
        ],
        "correct_index": 2,
        "explanation": "O clustering visa melhorar a performance de I/O armazenando linhas relacionadas (ou linhas na mesma ordem de um Ã­ndice frequentemente usado) prÃ³ximas no disco. Isso reduz o movimento da cabeÃ§a do disco (para HDDs) e o nÃºmero de blocos diferentes a serem lidos. ì˜¹ê¸°ì¢…ê¸°"
    },
    {
        "chapter": 5,
        "question": "O que o 'fator de clusterizaÃ§Ã£o' (index clustering factor) de um Ã­ndice tipicamente indica?",
        "options": [
            "A) O nÃºmero de colunas no Ã­ndice.",
            "B) QuÃ£o bem a ordem das chaves no Ã­ndice corresponde Ã  ordem fÃ­sica das linhas na tabela principal (heap table). Um valor baixo Ã© melhor.",
            "C) A porcentagem de dados da tabela que estÃ¡ coberta pelo Ã­ndice.",
            "D) A rapidez com que o Ã­ndice pode ser reconstruÃ­do."
        ],
        "correct_index": 1,
        "explanation": "Um fator de clusterizaÃ§Ã£o baixo significa que as entradas sequenciais do Ã­ndice tendem a apontar para linhas na tabela que estÃ£o no mesmo bloco de dados ou em blocos adjacentes. Um fator alto significa que o acesso Ã  tabela via Ã­ndice serÃ¡ mais aleatÃ³rio e custoso. ðŸ“‰ðŸ‘"
    },
    {
        "chapter": 5,
        "question": "O que Ã© um 'Index-Only Scan'?",
        "options": [
            "A) Uma varredura que lÃª apenas o primeiro nÃ­vel de um Ã­ndice B-Tree.",
            "B) Uma operaÃ§Ã£o onde o banco de dados pode satisfazer completamente uma consulta (incluindo todas as colunas do SELECT, WHERE, ORDER BY, etc.) usando apenas os dados contidos em um Ã­ndice, sem precisar acessar a tabela principal.",
            "C) Um tipo de scan que sÃ³ funciona em tabelas organizadas por Ã­ndice (IOTs).",
            "D) Uma varredura de Ã­ndice que ignora os predicados da clÃ¡usula WHERE."
        ],
        "correct_index": 1,
        "explanation": "Se todas as informaÃ§Ãµes que a consulta precisa estÃ£o disponÃ­veis no prÃ³prio Ã­ndice (um 'covering index'), o banco pode evitar o acesso custoso Ã  tabela principal, resultando em um Index-Only Scan. âœ¨"
    },
    {
        "chapter": 5,
        "question": "Qual Ã© uma das principais vantagens de uma 'Index-Organized Table' (IOT no Oracle) ou uma tabela com 'Clustered Index' (SQL Server, InnoDB no MySQL)?",
        "options": [
            "A) Elas sempre usam menos espaÃ§o em disco do que tabelas heap com Ã­ndices separados.",
            "B) As operaÃ§Ãµes de INSERT sÃ£o sempre mais rÃ¡pidas nelas.",
            "C) O acesso aos dados pela chave primÃ¡ria (que define a organizaÃ§Ã£o da tabela) Ã© muito rÃ¡pido, pois os dados da linha residem diretamente na estrutura do Ã­ndice.",
            "D) Elas permitem um nÃºmero ilimitado de Ã­ndices secundÃ¡rios sem perda de performance."
        ],
        "correct_index": 2,
        "explanation": "Em IOTs/tabelas com Ã­ndice clusterizado, a tabela Ã© o Ã­ndice primÃ¡rio. Portanto, o acesso via chave primÃ¡ria Ã© direto e nÃ£o requer um 'lookup' adicional para a tabela, pois os dados jÃ¡ estÃ£o lÃ¡. ðŸ "
    },
    {
        "chapter": 5,
        "question": "Qual Ã© uma desvantagem significativa dos Ã­ndices secundÃ¡rios em Index-Organized Tables (IOTs) ou tabelas com Clustered Index?",
        "options": [
            "A) Ãndices secundÃ¡rios nÃ£o sÃ£o permitidos nesse tipo de tabela.",
            "B) Eles tendem a ser muito pequenos, o que os torna ineficientes.",
            "C) Eles geralmente armazenam a(s) chave(s) do Ã­ndice clusterizado como ponteiro para a linha, o que pode levar a buscas duplas em Ã­ndice (uma no secundÃ¡rio, outra no clusterizado) e tornÃ¡-los maiores se a chave clusterizada for grande.",
            "D) Eles sÃ³ podem indexar colunas numÃ©ricas."
        ],
        "correct_index": 2,
        "explanation": "Como nÃ£o hÃ¡ um ROWID estÃ¡vel para a heap table (pois ela nÃ£o existe separadamente), os Ã­ndices secundÃ¡rios precisam apontar para a linha usando a chave do Ã­ndice primÃ¡rio/clusterizado. Isso pode levar a uma busca adicional e aumentar o tamanho dos Ã­ndices secundÃ¡rios. ðŸ˜Ÿ"
    },
    {
        "chapter": 5,
        "question": "Para que tipo de consulta um 'Index-Only Scan' Ã© particularmente benÃ©fico?",
        "options": [
            "A) Consultas que atualizam muitas colunas da tabela.",
            "B) Consultas que selecionam poucas colunas, e essas colunas (junto com as do WHERE e ORDER BY) estÃ£o todas presentes em um mesmo Ã­ndice.",
            "C) Consultas que sempre fazem `SELECT *`.",
            "D) Consultas que nÃ£o possuem clÃ¡usula WHERE."
        ],
        "correct_index": 1,
        "explanation": "Se vocÃª precisa de poucas colunas e consegue colocar todas elas em um Ã­ndice (incluindo as do WHERE, etc.), o banco pode evitar o acesso Ã  tabela, economizando I/O. `SELECT *` geralmente impede Index-Only Scans. ðŸŽ¯"
    },
    {
        "chapter": 5,
        "question": "O comando `CLUSTER` no PostgreSQL tem qual efeito principal?",
        "options": [
            "A) Cria um Ã­ndice clusterizado que Ã© mantido automaticamente pelo PostgreSQL, similar ao SQL Server.",
            "B) Reordena fisicamente a tabela no disco de acordo com a ordem de um Ã­ndice especificado, mas essa ordem nÃ£o Ã© mantida automaticamente para inserÃ§Ãµes e atualizaÃ§Ãµes futuras (Ã© uma operaÃ§Ã£o Ãºnica).",
            "C) Conecta mÃºltiplos servidores PostgreSQL em um cluster para alta disponibilidade.",
            "D) Comprime os dados da tabela para economizar espaÃ§o."
        ],
        "correct_index": 1,
        "explanation": "O comando `CLUSTER` no PostgreSQL reescreve a tabela baseada na ordem de um Ã­ndice. Ã‰ uma operaÃ§Ã£o one-time; a ordem nÃ£o Ã© mantida automaticamente depois disso. ðŸ”„"
    },
    {
        "chapter": 5,
        "question": "No MySQL com InnoDB, como as tabelas sÃ£o armazenadas por padrÃ£o?",
        "options": [
            "A) Como heap tables, com um Ã­ndice primÃ¡rio nÃ£o clusterizado opcional.",
            "B) Sempre como Index-Organized Tables (IOTs) baseadas na chave primÃ¡ria (Ã­ndice clusterizado). Se nenhuma PK Ã© definida, o InnoDB escolhe uma ou cria uma oculta.",
            "C) Em arquivos CSV simples para facilitar a importaÃ§Ã£o/exportaÃ§Ã£o.",
            "D) O DBA escolhe entre heap table e IOT no momento da criaÃ§Ã£o de cada tabela."
        ],
        "correct_index": 1,
        "explanation": "O InnoDB no MySQL organiza todas as tabelas como Ã­ndices clusterizados, usando a chave primÃ¡ria. Se nÃ£o houver PK, ele procura o primeiro Ã­ndice UNIQUE NOT NULL ou cria uma chave oculta.  InnoDB â¤ï¸ Clustered Index."
    },
    {
        "chapter": 5,
        "question": "Qual Ã© a principal motivaÃ§Ã£o para se preocupar com o 'clustering' de dados ou usar 'Index-Only Scans'?",
        "options": [
            "A) Reduzir o uso de CPU do servidor de banco de dados.",
            "B) Minimizar o nÃºmero de operaÃ§Ãµes de I/O de disco, que sÃ£o geralmente as operaÃ§Ãµes mais lentas em um sistema de banco de dados.",
            "C) Simplificar a sintaxe das consultas SQL.",
            "D) Aumentar a seguranÃ§a dos dados armazenados."
        ],
        "correct_index": 1,
        "explanation": "Tanto o agrupamento de dados quanto os Index-Only Scans visam reduzir a quantidade de leituras de disco necessÃ¡rias para satisfazer uma consulta, pois o I/O de disco Ã© um dos maiores gargalos de performance. ðŸš€"
    },
    {
        "chapter": 5,
        "question": "Se um Ã­ndice secundÃ¡rio em uma tabela com Ã­ndice clusterizado (ex: InnoDB) contÃ©m as colunas da chave clusterizada, para qual tipo de consulta esse Ã­ndice secundÃ¡rio poderia se tornar 'covering' (permitir um index-only scan) mesmo sem incluir todas as colunas do SELECT?",
        "options": [
            "A) Nunca, um Ã­ndice secundÃ¡rio nÃ£o pode ser 'covering' em tabelas clusterizadas.",
            "B) Se a consulta selecionar apenas colunas que fazem parte do prÃ³prio Ã­ndice secundÃ¡rio OU colunas que fazem parte da chave clusterizada (que tambÃ©m estÃ£o no Ã­ndice secundÃ¡rio).",
            "C) Apenas se o Ã­ndice secundÃ¡rio for tambÃ©m a chave primÃ¡ria.",
            "D) Apenas para consultas que usam funÃ§Ãµes de agregaÃ§Ã£o."
        ],
        "correct_index": 1,
        "explanation": "Como os Ã­ndices secundÃ¡rios em tabelas clusterizadas (como no InnoDB) incluem as colunas da chave primÃ¡ria (clusterizada), se sua consulta precisa apenas de colunas do Ã­ndice secundÃ¡rio e/ou colunas da PK, o banco pode satisfazer a consulta lendo apenas o Ã­ndice secundÃ¡rio. ðŸ‘"
    },
{
        "chapter": 6,
        "question": "Qual Ã© o 'terceiro poder da indexaÃ§Ã£o' (third power of indexing) mencionado no livro em relaÃ§Ã£o Ã  clÃ¡usula `ORDER BY`?",
        "options": [
            "A) A capacidade de um Ã­ndice ordenar dados em memÃ³ria mais rapidamente do que no disco.",
            "B) A capacidade de um Ã­ndice ser lido em ambas as direÃ§Ãµes (ascendente e descendente) para satisfazer diferentes ordens.",
            "C) A capacidade de um Ã­ndice fornecer dados jÃ¡ ordenados, permitindo que a operaÃ§Ã£o `ORDER BY` seja 'pipelined' (em pipeline), ou seja, o banco pode comeÃ§ar a retornar as primeiras linhas ordenadas sem processar todo o conjunto de dados.",
            "D) A capacidade de um Ã­ndice forÃ§ar uma ordenaÃ§Ã£o especÃ­fica, mesmo que o usuÃ¡rio peÃ§a outra."
        ],
        "correct_index": 2,
        "explanation": "Se um Ã­ndice pode satisfazer a clÃ¡usula `ORDER BY`, o banco de dados nÃ£o precisa realizar uma operaÃ§Ã£o de sort separada e custosa. Ele pode ler os dados jÃ¡ ordenados do Ã­ndice e comeÃ§ar a enviar as primeiras linhas imediatamente (execuÃ§Ã£o em pipeline). ðŸšš"
    },
    {
        "chapter": 6,
        "question": "Para que uma consulta com `ORDER BY col_a, col_b` evite uma operaÃ§Ã£o de `SORT` explÃ­cita, qual das seguintes condiÃ§Ãµes de Ã­ndice Ã© a mais ideal?",
        "options": [
            "A) Um Ã­ndice em `(col_b, col_a)`.",
            "B) Um Ã­ndice em `(col_a)` e outro Ã­ndice separado em `(col_b)`.",
            "C) Um Ã­ndice multicoluna em `(col_a, col_b)`.",
            "D) Um Ã­ndice em qualquer coluna da tabela, desde que seja B-Tree."
        ],
        "correct_index": 2,
        "explanation": "Para que o `ORDER BY` seja satisfeito diretamente pelo Ã­ndice, o Ã­ndice deve conter as colunas da clÃ¡usula `ORDER BY` na mesma ordem (ou em uma ordem que o banco possa usar, como a inversa) e as condiÃ§Ãµes da clÃ¡usula `WHERE` devem permitir o uso dessa ordem. ðŸŽ¼"
    },
    {
        "chapter": 6,
        "question": "Se vocÃª tem um Ã­ndice em `(data_evento ASC, prioridade ASC)` e sua consulta Ã© `SELECT * FROM eventos WHERE data_evento = '2024-05-23' ORDER BY prioridade ASC`, o banco de dados provavelmente evitarÃ¡ um sort explÃ­cito para `prioridade`?",
        "options": [
            "A) NÃ£o, porque `prioridade` nÃ£o Ã© a primeira coluna do Ã­ndice.",
            "B) Sim, porque a condiÃ§Ã£o de igualdade em `data_evento` fixa a primeira parte do Ã­ndice, e as entradas para essa data jÃ¡ estarÃ£o ordenadas por `prioridade` dentro do Ã­ndice.",
            "C) Apenas se `prioridade` for um nÃºmero inteiro.",
            "D) NÃ£o, porque `ORDER BY` com mÃºltiplas colunas sempre requer sort."
        ],
        "correct_index": 1,
        "explanation": "Quando a(s) primeira(s) coluna(s) de um Ã­ndice multicoluna sÃ£o fixadas por condiÃ§Ãµes de igualdade no `WHERE`, as colunas subsequentes do Ã­ndice podem ser usadas para satisfazer o `ORDER BY` para o subconjunto resultante. âœ…"
    },
    {
        "chapter": 6,
        "question": "Um banco de dados pode usar um Ã­ndice definido como `(col_x ASC, col_y ASC)` para satisfazer uma consulta com `ORDER BY col_x DESC, col_y DESC` sem um sort explÃ­cito?",
        "options": [
            "A) NÃ£o, as direÃ§Ãµes `ASC`/`DESC` devem corresponder exatamente.",
            "B) Sim, muitos SGBDs podem ler um Ã­ndice B-Tree em ambas as direÃ§Ãµes (para frente e para trÃ¡s).",
            "C) Apenas se `col_x` e `col_y` forem numÃ©ricas.",
            "D) Apenas se o Ã­ndice for do tipo Hash."
        ],
        "correct_index": 1,
        "explanation": "A maioria dos SGBDs modernos pode realizar um 'Index Backward Scan' (varredura de Ã­ndice para trÃ¡s), permitindo que um Ã­ndice `ASC` seja usado para uma ordenaÃ§Ã£o `DESC` (e vice-versa), desde que todas as colunas na ordenaÃ§Ã£o tenham a direÃ§Ã£o invertida de forma consistente. âª"
    },
    {
        "chapter": 6,
        "question": "Se uma consulta requer `ORDER BY col_A ASC, col_B DESC` (ordens mistas), o que Ã© necessÃ¡rio para que um Ã­ndice evite o sort?",
        "options": [
            "A) Um Ã­ndice em `(col_A ASC, col_B ASC)` Ã© suficiente, o banco ajusta.",
            "B) Um Ã­ndice em `(col_B DESC, col_A ASC)` Ã© a melhor opÃ§Ã£o.",
            "C) O Ã­ndice deve ser definido com as mesmas direÃ§Ãµes de ordenaÃ§Ã£o especificadas no `ORDER BY`, ou seja, `CREATE INDEX ... ON tabela (col_A ASC, col_B DESC)`.",
            "D) Ã‰ impossÃ­vel evitar o sort com ordens mistas."
        ],
        "correct_index": 2,
        "explanation": "Para ordens mistas no `ORDER BY`, o banco nÃ£o pode simplesmente ler um Ã­ndice padrÃ£o (todo `ASC` ou todo `DESC`) para frente ou para trÃ¡s. O Ã­ndice precisa ser criado explicitamente com essas ordens mistas para ser usado diretamente. ðŸ”„"
    },
    {
        "chapter": 6,
        "question": "Qual dos dois principais algoritmos de `GROUP BY` pode se beneficiar diretamente de um Ã­ndice para evitar uma ordenaÃ§Ã£o prÃ©via dos dados?",
        "options": [
            "A) O algoritmo 'Hash Aggregate'.",
            "B) O algoritmo 'Sort Aggregate' (ou 'Stream Aggregate').",
            "C) Ambos os algoritmos se beneficiam igualmente de qualquer Ã­ndice.",
            "D) Nenhum algoritmo de `GROUP BY` usa Ã­ndices, eles sempre ordenam ou usam hash em todos os dados."
        ],
        "correct_index": 1,
        "explanation": "O algoritmo 'Sort Aggregate' primeiro ordena os dados pelas colunas do `GROUP BY` e depois agrupa. Se um Ã­ndice jÃ¡ fornece os dados nessa ordem (devido a uma clÃ¡usula `WHERE` adequada), a etapa de sort pode ser pulada (o plano pode mostrar 'NOSORT' ou simplesmente nÃ£o ter um passo de sort antes da agregaÃ§Ã£o). åˆ†é¡žâž¡ï¸âž•"
    },
    {
        "chapter": 6,
        "question": "Para que um `GROUP BY col_categoria` seja otimizado por um Ã­ndice em `(col_categoria)`, qual condiÃ§Ã£o na clÃ¡usula `WHERE` seria mais favorÃ¡vel?",
        "options": [
            "A) Nenhuma condiÃ§Ã£o `WHERE`.",
            "B) `WHERE col_outra_coisa = 'valor'`, onde `col_outra_coisa` nÃ£o estÃ¡ no Ã­ndice.",
            "C) `WHERE col_categoria LIKE '%abc%'`.",
            "D) `WHERE col_categoria BETWEEN 'A' AND 'C'`."
        ],
        "correct_index": 3,
        "explanation": "Se a clÃ¡usula `WHERE` permite uma varredura de intervalo (range scan) no Ã­ndice `(col_categoria)` de forma que os dados jÃ¡ saiam agrupados ou ordenados por `col_categoria`, o `GROUP BY` pode ser mais eficiente. Uma condiÃ§Ã£o de igualdade ou um range pequeno na coluna do `GROUP BY` Ã© ideal. ðŸ‘"
    },
    {
        "chapter": 6,
        "question": "O que significa um `GROUP BY` 'pipelined' (em pipeline)?",
        "options": [
            "A) Que o `GROUP BY` Ã© executado em paralelo usando mÃºltiplos pipelines de CPU.",
            "B) Que o banco de dados pode comeÃ§ar a processar e agregar os grupos Ã  medida que lÃª os dados (geralmente de um Ã­ndice ordenado), sem precisar armazenar e ordenar todo o conjunto de dados primeiro.",
            "C) Que os resultados do `GROUP BY` sÃ£o enviados para outra consulta atravÃ©s de um pipeline.",
            "D) Um `GROUP BY` que usa apenas funÃ§Ãµes de agregaÃ§Ã£o que suportam pipeline."
        ],
        "correct_index": 1,
        "explanation": "Um `GROUP BY` em pipeline, assim como um `ORDER BY` em pipeline, significa que o banco nÃ£o precisa de uma etapa intermediÃ¡ria massiva de ordenaÃ§Ã£o ou hashing de todo o conjunto de dados antes de comeÃ§ar a produzir os grupos agregados. Isso Ã© possÃ­vel se um Ã­ndice fornecer os dados na ordem de agrupamento. ðŸ’§âž¡ï¸âž¡ï¸âž¡ï¸"
    },
    {
        "chapter": 6,
        "question": "Se um Ã­ndice Ã© `(A ASC, B DESC)`, qual `ORDER BY` NÃƒO pode usar este Ã­ndice diretamente para evitar um sort (sem ler o Ã­ndice ao contrÃ¡rio)?",
        "options": [
            "A) `ORDER BY A ASC, B DESC`",
            "B) `ORDER BY A ASC` (se o `WHERE` fixar A ou permitir um range scan em A)",
            "C) `ORDER BY A DESC, B ASC`",
            "D) `ORDER BY A ASC, B ASC`"
        ],
        "correct_index": 3,
        "explanation": "O Ã­ndice `(A ASC, B DESC)` fornece uma ordem especÃ­fica. `ORDER BY A ASC, B ASC` tem uma direÃ§Ã£o diferente para B, exigindo um novo sort. A opÃ§Ã£o C exigiria ler o Ã­ndice ao contrÃ¡rio. OpÃ§Ã£o A e B (parcialmente) podem usar o Ã­ndice. ðŸš§"
    },
    {
        "chapter": 6,
        "question": "AlÃ©m de `ORDER BY` e `GROUP BY`, qual outra operaÃ§Ã£o SQL pode se beneficiar de um Ã­ndice para evitar uma ordenaÃ§Ã£o explÃ­cita dos dados?",
        "options": [
            "A) `UNION ALL`",
            "B) `SELECT COUNT(*)` sem `WHERE`.",
            "C) `DISTINCT` (ou `SELECT DISTINCT ...`)",
            "D) Subconsultas correlacionadas."
        ],
        "correct_index": 2,
        "explanation": "A operaÃ§Ã£o `DISTINCT` precisa identificar valores Ãºnicos, o que Ã© frequentemente feito ordenando os dados e depois removendo duplicatas adjacentes. Se um Ã­ndice fornecer os dados jÃ¡ ordenados, essa etapa de sort pode ser evitada. âœ¨"
    },
    {
        "chapter": 7,
        "question": "Qual Ã© o principal problema de performance da paginaÃ§Ã£o usando `OFFSET` para buscar pÃ¡ginas distantes do inÃ­cio (ex: `LIMIT 10 OFFSET 50000`)?",
        "options": [
            "A) `OFFSET` sempre forÃ§a o banco a usar um Ã­ndice menos eficiente.",
            "B) O banco de dados precisa identificar, ordenar e depois *descartar* todas as N linhas do offset antes de poder retornar as M linhas da pÃ¡gina desejada, o que Ã© custoso para N grande.",
            "C) `OFFSET` nÃ£o Ã© uma clÃ¡usula SQL padrÃ£o e tem implementaÃ§Ãµes inconsistentes.",
            "D) `OFFSET` consome uma quantidade excessiva de espaÃ§o em disco temporÃ¡rio, independentemente do nÃºmero de linhas."
        ],
        "correct_index": 1,
        "explanation": "O `OFFSET` grande faz com que o banco de dados processe (busque, ordene e conte) muitas linhas que serÃ£o simplesmente descartadas, levando a uma degradaÃ§Ã£o de performance proporcional ao valor do offset. ðŸŒ"
    },
    {
        "chapter": 7,
        "question": "Qual Ã© a abordagem fundamental da 'Keyset Pagination' (PaginaÃ§Ã£o por Conjunto de Chaves ou Seek Method)?",
        "options": [
            "A) Usar a clÃ¡usula `OFFSET` de forma mais otimizada com um cÃ¡lculo de 'keyset'.",
            "B) Armazenar em cache todas as pÃ¡ginas na memÃ³ria da aplicaÃ§Ã£o.",
            "C) Usar os valores da(s) coluna(s) de ordenaÃ§Ã£o do Ãºltimo item da pÃ¡gina anterior para construir uma clÃ¡usula `WHERE` que busque diretamente o inÃ­cio da prÃ³xima pÃ¡gina.",
            "D) PrÃ©-calcular e armazenar os ROWIDs de cada linha de cada pÃ¡gina possÃ­vel."
        ],
        "correct_index": 2,
        "explanation": "A Keyset Pagination evita o `OFFSET` usando uma condiÃ§Ã£o `WHERE` baseada nos valores de ordenaÃ§Ã£o do Ãºltimo registro da pÃ¡gina anterior para 'saltar' diretamente para o prÃ³ximo conjunto de registros, usando um Ã­ndice. ðŸ”‘"
    },
    {
        "chapter": 7,
        "question": "Para que a Keyset Pagination funcione corretamente e de forma eficiente, quais sÃ£o os prÃ©-requisitos importantes para a clÃ¡usula `ORDER BY` e os Ã­ndices?",
        "options": [
            "A) O `ORDER BY` deve usar apenas uma coluna e essa coluna nÃ£o pode ser indexada.",
            "B) O `ORDER BY` deve garantir uma ordem estÃ¡vel e Ãºnica (frequentemente adicionando a chave primÃ¡ria como desempate), e deve haver um Ã­ndice que suporte essa ordenaÃ§Ã£o.",
            "C) NÃ£o Ã© necessÃ¡rio `ORDER BY`, pois o Keyset Pagination usa a ordem natural da tabela.",
            "D) Apenas um Ã­ndice do tipo Hash pode ser usado com Keyset Pagination."
        ],
        "correct_index": 1,
        "explanation": "Uma ordenaÃ§Ã£o estÃ¡vel e Ãºnica Ã© crucial para nÃ£o pular ou repetir registros. Um Ã­ndice que corresponda a essa ordenaÃ§Ã£o Ã© essencial para que o 'seek' (busca) para o prÃ³ximo conjunto de chaves seja eficiente. ðŸ”’"
    },
    {
        "chapter": 7,
        "question": "Qual Ã© uma limitaÃ§Ã£o comum da Keyset Pagination em termos de funcionalidade da interface do usuÃ¡rio (UI)?",
        "options": [
            "A) Ela nÃ£o funciona bem com ordenaÃ§Ã£o descendente (`DESC`).",
            "B) Ã‰ mais lenta que `OFFSET` para as primeiras pÃ¡ginas.",
            "C) Torna difÃ­cil ou ineficiente para o usuÃ¡rio pular diretamente para uma pÃ¡gina arbitrÃ¡ria (ex: ir da pÃ¡gina 1 para a pÃ¡gina 50) sem conhecer os 'cursores' intermediÃ¡rios.",
            "D) Ela nÃ£o pode ser usada com clÃ¡usulas `WHERE` complexas."
        ],
        "correct_index": 2,
        "explanation": "Como a Keyset Pagination depende dos valores da pÃ¡gina anterior para buscar a prÃ³xima, ela Ã© inerentemente sequencial ('PrÃ³ximo'/'Anterior'). Implementar um salto direto para um nÃºmero de pÃ¡gina especÃ­fico Ã© mais complexo. ðŸš¶âž¡ï¸ðŸš¶"
    },
    {
        "chapter": 7,
        "question": "Como a funÃ§Ã£o de janela `ROW_NUMBER() OVER (ORDER BY ...)` Ã© usada para implementar paginaÃ§Ã£o?",
        "options": [
            "A) Ela substitui a clÃ¡usula `OFFSET` nativamente, tornando-a mais rÃ¡pida.",
            "B) Ela Ã© usada em uma subconsulta (ou CTE) para atribuir um nÃºmero sequencial a cada linha baseado na ordenaÃ§Ã£o, e a consulta externa filtra por um intervalo desses nÃºmeros de linha.",
            "C) Ela sÃ³ pode ser usada para contar o nÃºmero total de pÃ¡ginas, nÃ£o para buscar os dados da pÃ¡gina.",
            "D) Ela cria um Ã­ndice temporÃ¡rio baseado na numeraÃ§Ã£o das linhas."
        ],
        "correct_index": 1,
        "explanation": "Primeiro, todas as linhas (ou as que passam por um filtro inicial) sÃ£o numeradas usando `ROW_NUMBER()`. Depois, uma consulta externa seleciona as linhas onde o nÃºmero gerado estÃ¡ dentro do intervalo da pÃ¡gina desejada (ex: `WHERE rn BETWEEN 21 AND 30`). ðŸ”¢"
    },
    {
        "chapter": 7,
        "question": "Comparando a paginaÃ§Ã£o com `ROW_NUMBER()` e a Keyset Pagination para buscar pÃ¡ginas muito distantes do inÃ­cio, qual geralmente oferece melhor performance?",
        "options": [
            "A) `ROW_NUMBER()` Ã© sempre mais rÃ¡pido porque usa funÃ§Ãµes de janela otimizadas.",
            "B) Ambas tÃªm performance idÃªntica em todos os cenÃ¡rios.",
            "C) Keyset Pagination Ã© geralmente mais performÃ¡tica porque evita a necessidade de processar/numerar todas as linhas atÃ© a pÃ¡gina desejada; ela 'salta' usando um Ã­ndice.",
            "D) Depende apenas do nÃºmero de colunas selecionadas."
        ],
        "correct_index": 2,
        "explanation": "Keyset Pagination tende a ser superior para paginaÃ§Ã£o profunda, pois o custo Ã© relativamente constante por pÃ¡gina. `ROW_NUMBER()` ainda precisa, conceitualmente, processar ou enumerar todas as linhas atÃ© o final da janela da pÃ¡gina desejada. ðŸš€ vs ðŸš¶â€â™€ï¸...ðŸš¶â€â™‚ï¸"
    },
    {
        "chapter": 7,
        "question": "Se uma consulta de paginaÃ§Ã£o usa `LIMIT N` (ou `Workspace FIRST N ROWS`) e tem uma clÃ¡usula `ORDER BY`, por que Ã© crucial que o `ORDER BY` seja suportado por um Ã­ndice?",
        "options": [
            "A) Para garantir que N seja sempre um nÃºmero par.",
            "B) Para que o banco de dados possa ler os dados jÃ¡ ordenados e parar de buscar assim que N linhas forem encontradas, evitando um 'Sort Limited' (ordenar muitos dados para pegar poucos).",
            "C) Porque `LIMIT` sÃ³ funciona sintaticamente se houver um `ORDER BY` indexado.",
            "D) Para reduzir o tamanho do Ã­ndice, tornando o `LIMIT` mais rÃ¡pido."
        ],
        "correct_index": 1,
        "explanation": "Com um `ORDER BY` indexado, o SGBD pode pegar as N primeiras linhas diretamente da ordem do Ã­ndice e parar. Sem isso, ele pode ter que buscar um grande conjunto de dados, ordenÃ¡-lo completamente (operaÃ§Ã£o custosa), e sÃ³ entÃ£o aplicar o `LIMIT`. ðŸ›‘"
    },
    {
        "chapter": 7,
        "question": "Para construir a clÃ¡usula `WHERE` da Keyset Pagination com `ORDER BY col_data DESC, col_id ASC`, se a Ãºltima linha da pÃ¡gina anterior foi `(data_X, id_Y)`, qual lÃ³gica Ã© a correta para buscar a prÃ³xima pÃ¡gina?",
        "options": [
            "A) `WHERE (col_data > data_X) OR (col_data = data_X AND col_id < id_Y)`",
            "B) `WHERE (col_data < data_X) OR (col_data = data_X AND col_id > id_Y)`",
            "C) `WHERE col_data < data_X AND col_id > id_Y`",
            "D) `WHERE col_data > data_X AND col_id < id_Y`"
        ],
        "correct_index": 1,
        "explanation": "Como `col_data` Ã© `DESC`, queremos datas 'menores' (mais antigas). Se a data for igual, como `col_id` Ã© `ASC`, queremos IDs 'maiores' para prosseguir. A forma `(col_data, col_id) < (data_X, id_Y)` em alguns SGBDs pode precisar ser escrita explicitamente como a opÃ§Ã£o B para ordens mistas. ðŸ‘‡ðŸ”¼"
    },
    {
        "chapter": 7,
        "question": "Qual tipo de retorno do Spring Data JPA (`Page<T>` vs `Slice<T>`) pode ajudar a otimizar a paginaÃ§Ã£o se a contagem total de elementos for custosa e nÃ£o necessÃ¡ria para cada requisiÃ§Ã£o?",
        "options": [
            "A) `Page<T>`, pois sempre inclui a contagem de forma otimizada.",
            "B) `Slice<T>`, pois nÃ£o executa a consulta de `COUNT(*)` para obter o total de elementos/pÃ¡ginas, apenas indica se hÃ¡ uma prÃ³xima 'fatia'.",
            "C) Ambos sÃ£o idÃªnticos em termos das queries executadas.",
            "D) Nenhum deles, a otimizaÃ§Ã£o de contagem deve ser feita manualmente."
        ],
        "correct_index": 1,
        "explanation": "`Slice<T>` Ã© uma otimizaÃ§Ã£o para cenÃ¡rios como 'scroll infinito' onde vocÃª sÃ³ precisa saber se hÃ¡ mais dados para carregar, evitando a query de `COUNT(*)` que `Page<T>` executa. ðŸ•"
    },
    {
        "chapter": 7,
        "question": "Ao implementar paginaÃ§Ã£o, qual Ã© o principal benefÃ­cio de usar uma 'coluna de desempate' Ãºnica (como a chave primÃ¡ria) no final da clÃ¡usula `ORDER BY`?",
        "options": [
            "A) Torna a consulta mais curta e fÃ¡cil de ler.",
            "B) Garante uma ordem estÃ¡vel e Ãºnica, prevenindo que registros sejam pulados ou repetidos entre as pÃ¡ginas, especialmente se as colunas primÃ¡rias de ordenaÃ§Ã£o tiverem valores duplicados.",
            "C) Permite que o banco de dados use sempre um 'Index-Only Scan'.",
            "D) Melhora a performance do `COUNT(*)`."
        ],
        "correct_index": 1,
        "explanation": "Se as colunas principais do `ORDER BY` podem ter valores iguais, a ordem das linhas com esses valores iguais pode ser indeterminada. Adicionar uma coluna Ãºnica (como a PK) no final do `ORDER BY` garante que a ordem total seja sempre a mesma, o que Ã© crucial para a corretude da Keyset Pagination. âš“"
    },
{
        "chapter": 8,
        "question": "Qual Ã© o principal impacto nos Ã­ndices quando vocÃª executa um `INSERT` em uma tabela com mÃºltiplos Ã­ndices?",
        "options": [
            "A) Nenhum, pois `INSERT`s sÃ³ afetam os dados da tabela principal e os Ã­ndices sÃ£o atualizados em background sem custo.",
            "B) Apenas o Ã­ndice primÃ¡rio Ã© atualizado; os demais sÃ£o marcados como 'dirty' para uma atualizaÃ§Ã£o posterior.",
            "C) Uma nova entrada deve ser adicionada em CADA um dos Ã­ndices da tabela, alÃ©m da inserÃ§Ã£o na prÃ³pria tabela.",
            "D) Os Ã­ndices sÃ£o temporariamente ignorados para acelerar a inserÃ§Ã£o e reconstruÃ­dos depois."
        ],
        "correct_index": 2,
        "explanation": "Para cada linha inserida na tabela, o banco de dados precisa adicionar uma entrada correspondente em todos os Ã­ndices existentes nessa tabela. Isso multiplica o trabalho de escrita. âœï¸âž¡ï¸ðŸ“ðŸ“ðŸ“"
    },
    {
        "chapter": 8,
        "question": "Ao fazer um `UPDATE` em uma linha, qual cenÃ¡rio geralmente resulta no MAIOR custo de performance relacionado a Ã­ndices?",
        "options": [
            "A) Atualizar uma coluna que nÃ£o faz parte de nenhum Ã­ndice.",
            "B) Atualizar uma coluna que faz parte de um ou mais Ã­ndices.",
            "C) O custo Ã© sempre o mesmo, pois o `UPDATE` reescreve a linha inteira na tabela.",
            "D) Atualizar a chave primÃ¡ria, mas apenas se ela nÃ£o for referenciada por chaves estrangeiras."
        ],
        "correct_index": 1,
        "explanation": "Atualizar uma coluna indexada Ã© custoso porque o banco precisa, efetivamente, tratar como um 'delete' da entrada antiga do Ã­ndice e um 'insert' da nova entrada, para cada Ã­ndice que contÃ©m a coluna modificada. ðŸ—‘ï¸âž•"
    },
    {
        "chapter": 8,
        "question": "Qual Ã© a principal vantagem de usar 'Bulk Inserts' (inserÃ§Ãµes em lote) em vez de inserir uma linha por vez em transaÃ§Ãµes separadas?",
        "options": [
            "A) Garante que cada linha inserida seja validada individualmente por constraints, tornando o processo mais seguro.",
            "B) Reduz o overhead de comunicaÃ§Ã£o com o banco, o overhead de transaÃ§Ã£o, e permite que o banco otimize as atualizaÃ§Ãµes dos Ã­ndices para o lote de linhas.",
            "C) Ocupa menos espaÃ§o no log de transaÃ§Ãµes porque apenas a primeira e a Ãºltima linha sÃ£o logadas.",
            "D) Melhora a legibilidade do cÃ³digo SQL, mas nÃ£o afeta a performance."
        ],
        "correct_index": 1,
        "explanation": "InserÃ§Ãµes em lote minimizam idas e vindas ao banco e permitem otimizaÃ§Ãµes internas na atualizaÃ§Ã£o de Ã­ndices, tornando o processo muito mais eficiente para mÃºltiplas linhas. ðŸššðŸ’¨"
    },
    {
        "chapter": 8,
        "question": "Em tabelas com Ã­ndice clusterizado (ex: InnoDB no MySQL, SQL Server) ou Index-Organized Tables (Oracle), qual prÃ¡tica de inserÃ§Ã£o pode ajudar a minimizar 'page splits'?",
        "options": [
            "A) Inserir dados em uma ordem completamente aleatÃ³ria para distribuir a carga.",
            "B) Inserir dados em uma ordem que se aproxime da ordem da chave do Ã­ndice clusterizado.",
            "C) Sempre inserir dados usando a clÃ¡usula `WITH (NOLOCK)`.",
            "D) Inserir cada linha em uma transaÃ§Ã£o separada."
        ],
        "correct_index": 1,
        "explanation": "Inserir dados em uma ordem que corresponda Ã  chave de clusterizaÃ§Ã£o permite que as novas linhas sejam adicionadas de forma mais sequencial nas pÃ¡ginas de dados, reduzindo a necessidade de dividir pÃ¡ginas existentes, o que Ã© custoso. âž¡ï¸ðŸ“„âž¡ï¸ðŸ“„"
    },
    {
        "chapter": 8,
        "question": "Para otimizar `UPDATE` e `DELETE`, qual Ã© a recomendaÃ§Ã£o mais crucial em relaÃ§Ã£o Ã  clÃ¡usula `WHERE`?",
        "options": [
            "A) Evitar o uso da clÃ¡usula `WHERE` para garantir que todas as linhas sejam processadas consistentemente.",
            "B) Usar funÃ§Ãµes complexas na clÃ¡usula `WHERE` para flexibilidade.",
            "C) Garantir que a clÃ¡usula `WHERE` possa utilizar eficientemente um Ã­ndice para localizar rapidamente as linhas a serem modificadas ou deletadas.",
            "D) Sempre usar subconsultas na clÃ¡usula `WHERE` para `UPDATE` e `DELETE`."
        ],
        "correct_index": 2,
        "explanation": "Assim como nos `SELECT`s, a clÃ¡usula `WHERE` de `UPDATE`s e `DELETE`s deve ser SARGable e usar colunas indexadas para que o banco encontre as linhas alvo rapidamente, evitando full table scans. ðŸŽ¯"
    },
    {
        "chapter": 8,
        "question": "Qual a diferenÃ§a fundamental entre `DELETE FROM tabela;` (sem `WHERE`) e `TRUNCATE TABLE tabela;`?",
        "options": [
            "A) Nenhuma, ambas fazem exatamente a mesma coisa com a mesma performance.",
            "B) `DELETE` Ã© mais rÃ¡pido pois nÃ£o precisa logar, enquanto `TRUNCATE` loga cada linha.",
            "C) `DELETE` remove linhas uma a uma (operacÃ£o DML, logada, dispara triggers), enquanto `TRUNCATE` remove todas as linhas de forma muito mais eficiente (geralmente DDL, minimamente logada, nÃ£o dispara triggers `ON DELETE`).",
            "D) `TRUNCATE` permite uma clÃ¡usula `WHERE`, enquanto `DELETE` sem `WHERE` apaga tudo."
        ],
        "correct_index": 2,
        "explanation": "`TRUNCATE` Ã© muito mais rÃ¡pido para limpar uma tabela inteira, pois lida com as pÃ¡ginas de dados de forma mais direta, com menos overhead de log e sem disparar triggers de linha. Mas cuidado, geralmente nÃ£o pode ser desfeito com `ROLLBACK`! ðŸ§¹ðŸ’¨"
    },
    {
        "chapter": 8,
        "question": "O que Ã© o problema da 'atualizaÃ§Ã£o perdida' (lost update problem) em um ciclo de 'ler-modificar-escrever' concorrente?",
        "options": [
            "A) Quando um `UPDATE` falha e os dados sÃ£o perdidos devido a um erro de disco.",
            "B) Quando duas transaÃ§Ãµes leem o mesmo dado, ambas o modificam, e a escrita da segunda transaÃ§Ã£o sobrescreve a escrita da primeira, fazendo com que as modificaÃ§Ãµes da primeira sejam perdidas.",
            "C) Quando o log de transaÃ§Ãµes perde o registro de um `UPDATE` bem-sucedido.",
            "D) Quando um `UPDATE` Ã© tÃ£o lento que o usuÃ¡rio desiste e perde os dados que queria salvar."
        ],
        "correct_index": 1,
        "explanation": "Isso acontece quando transaÃ§Ãµes concorrentes nÃ£o coordenam suas atualizaÃ§Ãµes, e uma sobrescreve o trabalho da outra sem perceber. ðŸ’”"
    },
    {
        "chapter": 8,
        "question": "Como o 'Optimistic Locking' (Travamento Otimista) geralmente funciona para prevenir o problema da atualizaÃ§Ã£o perdida?",
        "options": [
            "A) Bloqueando a linha com `SELECT ... FOR UPDATE` assim que ela Ã© lida, impedindo qualquer outra transaÃ§Ã£o de acessÃ¡-la.",
            "B) Utilizando uma coluna de versÃ£o (ou timestamp); o `UPDATE` sÃ³ Ã© permitido se a versÃ£o da linha no banco nÃ£o mudou desde que foi lida, e a versÃ£o Ã© incrementada na atualizaÃ§Ã£o.",
            "C) Serializando todas as transaÃ§Ãµes que tentam acessar a mesma tabela.",
            "D) Permitindo que as atualizaÃ§Ãµes perdidas aconteÃ§am, mas registrando-as para correÃ§Ã£o manual posterior."
        ],
        "correct_index": 1,
        "explanation": "O Travamento Otimista assume que conflitos sÃ£o raros. Ele verifica no momento do `UPDATE` se o dado foi alterado por outra transaÃ§Ã£o (comparando a versÃ£o). Se sim, o `UPDATE` falha (afeta 0 linhas) e a aplicaÃ§Ã£o lida com o conflito. âœ…âž¡ï¸â“âž¡ï¸ðŸ‘/ðŸ‘Ž"
    },
    {
        "chapter": 8,
        "question": "Qual a principal desvantagem do 'Pessimistic Locking' (ex: `SELECT ... FOR UPDATE`) em ambientes com alta concorrÃªncia?",
        "options": [
            "A) Ã‰ mais complexo de implementar do que o Travamento Otimista.",
            "B) Pode levar a deadlocks com mais frequÃªncia se nÃ£o for usado corretamente.",
            "C) Reduz a concorrÃªncia, pois as transaÃ§Ãµes podem ter que esperar por longos perÃ­odos para que os locks nas linhas sejam liberados, causando gargalos.",
            "D) NÃ£o Ã© suportado por todos os bancos de dados SQL padrÃ£o."
        ],
        "correct_index": 2,
        "explanation": "Ao bloquear linhas por perÃ­odos mais longos, o Travamento Pessimista pode fazer com que muitas transaÃ§Ãµes fiquem enfileiradas esperando, o que limita quantas operaÃ§Ãµes podem ocorrer simultaneamente. â³ðŸš¶ðŸš¶ðŸš¶"
    },
    {
        "chapter": 8,
        "question": "Se um ORM (como Hibernate/JPA) atualiza uma entidade enviando todos os seus campos mapeados na instruÃ§Ã£o `UPDATE SQL`, mesmo que apenas um campo tenha mudado, por que isso pode ser um problema de performance, conforme discutido no livro?",
        "options": [
            "A) Isso nÃ£o Ã© um problema, pois os SGBDs modernos ignoram campos nÃ£o alterados no `SET`.",
            "B) Pode causar a atualizaÃ§Ã£o desnecessÃ¡ria de colunas indexadas, levando Ã  manutenÃ§Ã£o custosa desses Ã­ndices, alÃ©m de maior trÃ¡fego de rede e log.",
            "C) Principalmente porque aumenta o tamanho do objeto entidade na memÃ³ria da aplicaÃ§Ã£o.",
            "D) Apenas se a tabela tiver triggers `ON UPDATE` para cada coluna."
        ],
        "correct_index": 1,
        "explanation": "Se colunas indexadas sÃ£o incluÃ­das no `SET` de um `UPDATE` (mesmo que seus valores nÃ£o tenham mudado em relaÃ§Ã£o ao que jÃ¡ estÃ¡ no banco), o SGBD pode ainda ter que fazer trabalho de manutenÃ§Ã£o nesses Ã­ndices, o que Ã© ineficiente. ConfiguraÃ§Ãµes como `@DynamicUpdate` (Hibernate) ou o uso de JPQL `UPDATE`s podem mitigar isso. ðŸ› ï¸ðŸŒ"
    }
]



