[
    {
        "chapter": 1,
        "question": "Qual √© a principal estrutura de dados que a maioria dos bancos de dados SQL relacionais utiliza para implementar √≠ndices?",
        "options": [
            "A) Hash Table",
            "B) B-Tree (ou suas varia√ß√µes como B+Tree)",
            "C) Linked List",
            "D) Red-Black Tree"
        ],
        "correct_index": 1,
        "explanation": "B-Trees (e suas varia√ß√µes como B+Trees) s√£o eficientes para buscas de valores exatos e varreduras de intervalo (range scans), sendo a estrutura padr√£o para √≠ndices devido ao seu balanceamento e performance logar√≠tmica. üå≥"
    },
    {
        "chapter": 1,
        "question": "O que um 'n√≥ folha' (leaf node) em um √≠ndice B-Tree normalmente cont√©m, al√©m do valor da chave indexada?",
        "options": [
            "A) Apenas ponteiros para outros n√≥s folha.",
            "B) Um ponteiro para a linha de dados real na tabela (ex: ROWID) e, em B+Trees, ponteiros para os n√≥s folha vizinhos.",
            "C) Uma c√≥pia completa de todas as outras colunas da tabela.",
            "D) Metadados sobre a estrutura da B-Tree."
        ],
        "correct_index": 1,
        "explanation": "Os n√≥s folha de um √≠ndice B-Tree (especialmente B+Tree) cont√™m os valores das chaves indexadas, um ponteiro (como ROWID) para a localiza√ß√£o da linha completa na tabela (heap table) e ponteiros para os n√≥s folha adjacentes para facilitar varreduras de intervalo. üçÉ"
    },
    {
        "chapter": 1,
        "question": "O que significa o termo 'SARGable' (Search Argument Able) em rela√ß√£o a um predicado na cl√°usula WHERE?",
        "options": [
            "A) Um predicado que s√≥ pode ser usado com argumentos do tipo string.",
            "B) Um predicado que √© muito complexo para o otimizador entender.",
            "C) Um predicado que est√° formulado de tal maneira que o banco de dados pode usar um √≠ndice para satisfaz√™-lo eficientemente.",
            "D) Um predicado que garante um 'Index-Only Scan'."
        ],
        "correct_index": 2,
        "explanation": "Um predicado SARGable (Search ARGument Able) permite que o mecanismo de busca do banco de dados use um √≠ndice para restringir o conjunto de linhas a serem examinadas, em vez de fazer um table scan. üëç"
    },
    {
        "chapter": 1,
        "question": "Qual das seguintes condi√ß√µes na cl√°usula WHERE √© MENOS prov√°vel de ser SARGable e, portanto, impedir o uso eficiente de um √≠ndice padr√£o na coluna `data_evento`?",
        "options": [
            "A) `WHERE data_evento = '2024-01-15'`",
            "B) `WHERE data_evento BETWEEN '2024-01-01' AND '2024-01-31'`",
            "C) `WHERE TO_CHAR(data_evento, 'YYYY') = '2024'`",
            "D) `WHERE data_evento > '2024-01-01'`"
        ],
        "correct_index": 2,
        "explanation": "Aplicar uma fun√ß√£o (como TO_CHAR) a uma coluna indexada no lado esquerdo do predicado geralmente torna o predicado non-SARGable para um √≠ndice padr√£o nessa coluna, pois o banco teria que calcular a fun√ß√£o para cada linha antes de comparar. FUNC(coluna) = valor üö´"
    },
    {
        "chapter": 1,
        "question": "O que √© um 'Table Access by Index ROWID' (ou equivalente) no plano de execu√ß√£o de uma consulta?",
        "options": [
            "A) Uma opera√ß√£o que indica que a consulta foi totalmente satisfeita pelo √≠ndice (Index-Only Scan).",
            "B) Uma opera√ß√£o onde o banco de dados usa o ROWID (ou ponteiro similar) obtido de uma varredura de √≠ndice para localizar e buscar a linha completa na tabela principal.",
            "C) Um erro que ocorre quando o ROWID n√£o √© encontrado.",
            "D) Uma opera√ß√£o que sempre √© mais r√°pida que um Full Table Scan."
        ],
        "correct_index": 1,
        "explanation": "Ap√≥s encontrar uma entrada de chave em um √≠ndice, se a consulta precisa de colunas n√£o presentes no √≠ndice, o banco de dados usa o ponteiro (ROWID) para acessar a tabela principal e buscar o restante dos dados da linha. üîç"
    },
    {
        "chapter": 1,
        "question": "Qual o principal benef√≠cio de um √≠ndice em termos de performance de `SELECT`?",
        "options": [
            "A) Reduzir o espa√ßo em disco usado pela tabela.",
            "B) Acelerar opera√ß√µes de `INSERT` e `UPDATE`.",
            "C) Reduzir o n√∫mero de blocos de dados que precisam ser lidos do disco para satisfazer uma consulta.",
            "D) Garantir a atomicidade das transa√ß√µes."
        ],
        "correct_index": 2,
        "explanation": "Os √≠ndices permitem que o banco de dados localize rapidamente as linhas que correspondem aos crit√©rios de uma consulta sem ter que varrer a tabela inteira, reduzindo significativamente o I/O de disco e o tempo de resposta. üíæ‚û°Ô∏è‚ö°"
    },
    {
        "chapter": 1,
        "question": "Se uma consulta `SELECT col1, col2 FROM tabela WHERE col3 = 100` √© executada, e existe um √≠ndice apenas na `col3`, qual √© um resultado prov√°vel no plano de execu√ß√£o se `col1` e `col2` n√£o estiverem nesse √≠ndice?",
        "options": [
            "A) Full Table Scan, porque `col1` e `col2` n√£o est√£o no √≠ndice.",
            "B) Index Scan em `col3` seguido de Table Access by ROWID para buscar `col1` e `col2`.",
            "C) Index-Only Scan, pois a condi√ß√£o `WHERE` usa um √≠ndice.",
            "D) O banco criar√° um √≠ndice tempor√°rio em `col1` e `col2`."
        ],
        "correct_index": 1,
        "explanation": "O √≠ndice em `col3` ser√° usado para encontrar as linhas relevantes (Index Scan). Como `col1` e `col2` n√£o est√£o nesse √≠ndice, o banco precisar√° acessar a tabela principal (Table Access) para obter esses valores para as linhas encontradas. üéØ"
    },
    {
        "chapter": 1,
        "question": "O que √© 'seletividade' (selectivity) de um valor em uma coluna indexada?",
        "options": [
            "A) A capacidade de um √≠ndice selecionar todas as colunas da tabela.",
            "B) Uma medida de qu√£o poucas linhas um valor espec√≠fico da coluna indexada retorna; alta seletividade significa que o valor √© raro e retorna poucas linhas.",
            "C) A garantia de que a consulta `SELECT` usar√° o √≠ndice, independentemente do valor.",
            "D) O n√∫mero de colunas inclu√≠das em um √≠ndice."
        ],
        "correct_index": 1,
        "explanation": "Alta seletividade (um valor que aparece em poucas linhas) torna o √≠ndice muito eficaz para esse valor, pois ele restringe drasticamente o conjunto de resultados. Baixa seletividade (um valor que aparece em muitas linhas) torna o √≠ndice menos √∫til para esse valor espec√≠fico. üìä"
    },
    {
        "chapter": 1,
        "question": "A profundidade de uma B-Tree (n√∫mero de n√≠veis do topo √† folha) geralmente cresce de que forma em rela√ß√£o ao n√∫mero de linhas na tabela?",
        "options": [
            "A) Linearmente (ex: dobrar as linhas dobra a profundidade).",
            "B) Exponencialmente (ex: dobrar as linhas quadruplica a profundidade).",
            "C) Logaritmicamente (ex: a profundidade cresce muito lentamente, mesmo com um grande aumento de linhas).",
            "D) Permanece constante ap√≥s a B-Tree atingir 3 n√≠veis."
        ],
        "correct_index": 2,
        "explanation": "A profundidade de uma B-Tree cresce logaritmicamente com o n√∫mero de entradas. Isso √© fundamental para sua efici√™ncia, pois mesmo para tabelas com milh√µes ou bilh√µes de linhas, a profundidade do √≠ndice permanece pequena (geralmente 3 a 5 n√≠veis), garantindo buscas r√°pidas. üê¢‚û°Ô∏èüêá"
    },
    {
        "chapter": 1,
        "question": "Considerando um √≠ndice na coluna `status_pedido` (que pode ter valores como 'PENDENTE', 'PAGO', 'ENVIADO', 'CANCELADO'), qual tipo de consulta se beneficiaria MENOS desse √≠ndice se a distribui√ß√£o de status for muito desigual (ex: 90% dos pedidos est√£o como 'ENVIADO')?",
        "options": [
            "A) `WHERE status_pedido = 'PENDENTE'` (supondo que 'PENDENTE' √© raro)",
            "B) `WHERE status_pedido = 'ENVIADO'` (supondo que 'ENVIADO' √© muito comum)",
            "C) `WHERE status_pedido IN ('PENDENTE', 'PAGO')` (supondo que ambos s√£o raros)",
            "D) Todas as consultas se beneficiariam igualmente."
        ],
        "correct_index": 1,
        "explanation": "Um √≠ndice √© menos eficaz (e o otimizador pode at√© optar por n√£o us√°-lo) para buscar valores de baixa seletividade, ou seja, valores que aparecem em uma grande porcentagem das linhas da tabela. Se 'ENVIADO' √© muito comum, buscar por ele pode resultar na leitura de grande parte da tabela de qualquer maneira. üìâ"
    },
{
        "chapter": 2,
        "question": "Qual √© a 'leading edge' (borda principal ou parte inicial) de um √≠ndice multicoluna, por exemplo, em `(col_A, col_B, col_C)`?",
        "options": [
            "A) Apenas a coluna C, por ser a √∫ltima e mais espec√≠fica.",
            "B) Qualquer combina√ß√£o das colunas A, B, ou C, em qualquer ordem.",
            "C) A coluna A sozinha, ou o par (col_A, col_B), ou o trio (col_A, col_B, col_C), indicando que as colunas devem ser usadas em ordem a partir da primeira.",
            "D) Apenas a coluna do meio (col_B), para fins de balanceamento do √≠ndice."
        ],
        "correct_index": 2,
        "explanation": "A 'leading edge' refere-se ao uso da(s) primeira(s) coluna(s) do √≠ndice, na ordem em que foram definidas. Para o √≠ndice (A,B,C), a borda principal pode ser A, (A,B) ou (A,B,C). Condi√ß√µes que usam essa borda s√£o mais eficientes. üìè"
    },
    {
        "chapter": 2,
        "question": "Se voc√™ tem um √≠ndice multicoluna em `(sobrenome, primeiro_nome)`, qual das seguintes cl√°usulas `WHERE` N√ÉO poder√° usar este √≠ndice de forma otimizada para um 'seek' ou 'range scan' eficiente?",
        "options": [
            "A) `WHERE sobrenome = 'Silva' AND primeiro_nome = 'Jo√£o'`",
            "B) `WHERE sobrenome = 'Silva'`",
            "C) `WHERE primeiro_nome = 'Jo√£o'`",
            "D) `WHERE sobrenome LIKE 'S%'`"
        ],
        "correct_index": 2,
        "explanation": "Um √≠ndice multicoluna geralmente requer que a(s) primeira(s) coluna(s) do √≠ndice (a 'leading edge') sejam usadas na cl√°usula WHERE para uma busca eficiente. Consultar apenas por `primeiro_nome` 'pula' a primeira coluna do √≠ndice (`sobrenome`), tornando o uso do √≠ndice menos eficiente ou imposs√≠vel para um seek direto. üîç"
    },
    {
        "chapter": 2,
        "question": "Ao definir a ordem das colunas em um √≠ndice multicoluna, qual √© uma heur√≠stica comum para otimizar consultas que usam condi√ß√µes de igualdade (`=`) e de intervalo (`>`, `<`, `BETWEEN`)?",
        "options": [
            "A) Sempre colocar as colunas usadas em condi√ß√µes de intervalo primeiro.",
            "B) Colocar as colunas usadas em condi√ß√µes de igualdade primeiro, seguidas pelas colunas usadas em condi√ß√µes de intervalo.",
            "C) A ordem n√£o importa se todas as colunas do WHERE estiverem no √≠ndice.",
            "D) Colocar as colunas com menor seletividade primeiro."
        ],
        "correct_index": 1,
        "explanation": "Para m√°xima efici√™ncia, as colunas usadas com predicados de igualdade devem vir primeiro no √≠ndice. A primeira coluna com uma condi√ß√£o de intervalo pode usar o √≠ndice para um range scan, mas as colunas subsequentes no √≠ndice geralmente s√≥ servir√£o para filtragem adicional, n√£o para restringir o range inicial. (=, =, >) ‚úÖ"
    },
    {
        "chapter": 2,
        "question": "Um 'Index-Only Scan' √© poss√≠vel com um √≠ndice multicoluna em `(col_A, col_B, col_C)` se a consulta for `SELECT col_A, col_B FROM tabela WHERE col_A = 10 AND col_B > 5`?",
        "options": [
            "A) N√£o, pois a coluna C do √≠ndice n√£o est√° no SELECT nem no WHERE.",
            "B) Sim, porque todas as colunas necess√°rias para o SELECT (`col_A`, `col_B`) e para o WHERE (`col_A`, `col_B`) est√£o presentes no √≠ndice.",
            "C) Apenas se `col_A` e `col_B` juntas formarem uma chave prim√°ria.",
            "D) N√£o, Index-Only Scans s√≥ funcionam com √≠ndices de coluna √∫nica."
        ],
        "correct_index": 1,
        "explanation": "Um Index-Only Scan √© poss√≠vel se todas as colunas referenciadas em todas as partes da consulta (SELECT, WHERE, ORDER BY, GROUP BY) estiverem contidas no √≠ndice. Neste caso, `col_A` e `col_B` est√£o no √≠ndice. üíØ"
    },
    {
        "chapter": 2,
        "question": "Se uma consulta tem `WHERE col_A > 10 AND col_B = 5` e existe um √≠ndice multicoluna em `(col_A, col_B)`, como o banco de dados provavelmente usar√° o √≠ndice?",
        "options": [
            "A) O √≠ndice n√£o pode ser usado porque a primeira coluna (`col_A`) tem uma condi√ß√£o de intervalo e a segunda (`col_B`) tem uma condi√ß√£o de igualdade.",
            "B) Apenas a condi√ß√£o `col_B = 5` ser√° usada para um 'index seek', e `col_A > 10` ser√° um filtro residual.",
            "C) O √≠ndice ser√° usado para um 'range scan' em `col_A` (para `col_A > 10`), e a condi√ß√£o `col_B = 5` ser√° aplicada como um predicado de filtro nas entradas do √≠ndice encontradas.",
            "D) O banco far√° duas varreduras de √≠ndice separadas e depois juntar√° os resultados."
        ],
        "correct_index": 2,
        "explanation": "O banco pode fazer um range scan no √≠ndice para `col_A > 10`. Para as entradas do √≠ndice que satisfazem essa condi√ß√£o, ele ent√£o verifica se `col_B = 5`. A coluna `col_B` n√£o pode ser usada para um 'seek' inicial ap√≥s uma condi√ß√£o de range em `col_A`. (>)"
    },
    {
        "chapter": 2,
        "question": "Considerando a consulta `SELECT * FROM pedidos WHERE cliente_id = ? AND status_pedido = ?`, qual √≠ndice seria geralmente mais ben√©fico se `cliente_id` for muito mais seletivo que `status_pedido`?",
        "options": [
            "A) Um √≠ndice em `(status_pedido, cliente_id)`.",
            "B) Um √≠ndice em `(cliente_id, status_pedido)`.",
            "C) Dois √≠ndices separados: um em `cliente_id` e outro em `status_pedido`.",
            "D) Nenhum √≠ndice √© necess√°rio se a tabela for pequena."
        ],
        "correct_index": 1,
        "explanation": "Colocar a coluna mais seletiva (`cliente_id`) primeiro no √≠ndice multicoluna permite que o banco reduza o conjunto de linhas candidatas mais rapidamente. O filtro por `status_pedido` √© ent√£o aplicado a um conjunto menor. üéØ"
    },
    {
        "chapter": 2,
        "question": "Quando um √≠ndice em `(A, B)` √© mais vantajoso do que ter dois √≠ndices separados, um em `A` e outro em `B`?",
        "options": [
            "A) Sempre, pois ocupa menos espa√ßo.",
            "B) Principalmente quando as consultas frequentemente filtram por `A` e `B` juntos (ex: `WHERE A = ? AND B = ?`) ou quando um Index-Only Scan pode ser satisfeito pelo √≠ndice `(A, B)`.",
            "C) Apenas se a coluna `B` for uma chave estrangeira para `A`.",
            "D) Ter dois √≠ndices separados √© sempre prefer√≠vel para flexibilidade."
        ],
        "correct_index": 1,
        "explanation": "Um √≠ndice concatenado `(A, B)` √© otimizado para consultas que usam a 'leading edge' (A, ou A e B). Ele tamb√©m pode cobrir consultas que selecionam A e B. Dois √≠ndices separados n√£o oferecem a mesma ordena√ß√£o combinada e podem exigir que o banco combine os resultados dos dois √≠ndices, o que pode ser menos eficiente. ü§ù"
    },
    {
        "chapter": 2,
        "question": "Em um √≠ndice `(regiao, cidade, bairro)`, uma consulta com `WHERE regiao = 'SUDESTE' AND bairro = 'CENTRO'` pode usar eficientemente todas as partes do √≠ndice para um 'seek' direto?",
        "options": [
            "A) Sim, o otimizador pode usar as colunas do √≠ndice em qualquer ordem.",
            "B) N√£o, porque a coluna `cidade` foi 'pulada' na condi√ß√£o WHERE, quebrando a 'leading edge' do √≠ndice ap√≥s `regiao`.",
            "C) Sim, desde que `bairro` seja uma coluna altamente seletiva.",
            "D) Apenas se `regiao`, `cidade`, e `bairro` forem todas do tipo VARCHAR."
        ],
        "correct_index": 1,
        "explanation": "Para que um √≠ndice multicoluna seja usado eficientemente em todas as suas partes para um 'seek' ou 'range scan' preciso, as condi√ß√µes na cl√°usula `WHERE` devem corresponder a um prefixo cont√≠nuo das colunas do √≠ndice. Pular uma coluna intermedi√°ria (`cidade` neste caso) impede o uso otimizado das colunas subsequentes (`bairro`) para refinar o 'seek' inicial. üöß"
    },
    {
        "chapter": 2,
        "question": "Se um √≠ndice multicoluna √© `(data_pedido, cliente_id, status)` e a consulta √© `SELECT ... FROM pedidos WHERE cliente_id = 123 ORDER BY data_pedido`, o √≠ndice pode ser usado para a cl√°usula `ORDER BY`?",
        "options": [
            "A) Sim, diretamente, pois `data_pedido` est√° no √≠ndice.",
            "B) N√£o, porque `data_pedido` n√£o √© a primeira coluna do √≠ndice e a cl√°usula `WHERE` n√£o a utiliza para restringir o range de forma a garantir a ordem por `data_pedido` para o `cliente_id` espec√≠fico.",
            "C) Sim, mas apenas se `cliente_id` for a chave prim√°ria.",
            "D) Apenas se a consulta tamb√©m incluir `WHERE data_pedido > 'alguma_data'`."
        ],
        "correct_index": 1,
        "explanation": "Para que um √≠ndice multicoluna satisfa√ßa um `ORDER BY`, as colunas do `ORDER BY` devem corresponder a um prefixo do √≠ndice, e as colunas anteriores a elas no √≠ndice devem ter condi√ß√µes de igualdade no `WHERE`. Aqui, `cliente_id` √© filtrado, mas n√£o h√° garantia de que os resultados para esse cliente estar√£o ordenados por `data_pedido` sem um sort adicional, pois `data_pedido` n√£o √© a primeira coluna usada pelo `WHERE` de forma a manter sua ordem natural para o subconjunto filtrado. ‚ö†Ô∏è"
    },
    {
        "chapter": 2,
        "question": "Qual afirma√ß√£o sobre √≠ndices multicoluna √© geralmente VERDADEIRA?",
        "options": [
            "A) Adicionar mais colunas a um √≠ndice sempre melhora a performance de todas as consultas.",
            "B) A ordem das colunas em um √≠ndice multicoluna n√£o afeta como ele √© utilizado pelo otimizador.",
            "C) Um √≠ndice multicoluna pode ser usado para satisfazer uma consulta mesmo que apenas a segunda ou terceira coluna do √≠ndice seja referenciada no WHERE, desde que com igualdade.",
            "D) A efic√°cia de um √≠ndice multicoluna depende crucialmente da ordem das suas colunas e de como as cl√°usulas WHERE e ORDER BY interagem com essa ordem."
        ],
        "correct_index": 3,
        "explanation": "A ordem das colunas √© fundamental. A 'leading edge' do √≠ndice deve ser utilizada pela cl√°usula WHERE para que o √≠ndice seja eficaz. Adicionar colunas desnecess√°rias pode aumentar o tamanho do √≠ndice e o custo de manuten√ß√£o. Usar colunas do meio sem as primeiras n√£o √© eficiente. üßê"
    },
{
        "chapter": 3,
        "question": "Qual das seguintes consultas com o operador `LIKE` tem maior probabilidade de utilizar um √≠ndice padr√£o na coluna `nome_produto` de forma eficiente?",
        "options": [
            "A) `WHERE nome_produto LIKE '%Caneta%'` (curinga no in√≠cio e no fim)",
            "B) `WHERE nome_produto LIKE 'Caneta%'` (curinga apenas no fim)",
            "C) `WHERE nome_produto LIKE '%Azul'` (curinga apenas no in√≠cio)",
            "D) Todas as op√ß√µes acima usar√£o o √≠ndice da mesma forma."
        ],
        "correct_index": 1,
        "explanation": "Um `LIKE` com um curinga (`%` ou `_`) no in√≠cio de um padr√£o (`'%Termo'` ou `'%Termo%'`) geralmente impede o uso de um √≠ndice B-Tree padr√£o para um 'seek' ou 'range scan' eficiente. `LIKE 'Termo%'` pode usar o √≠ndice porque o prefixo √© conhecido. üîé"
    },
    {
        "chapter": 3,
        "question": "O que √© um 'Function-Based Index' (√çndice Baseado em Fun√ß√£o) ou 'Index on Expression' (√çndice em Express√£o)?",
        "options": [
            "A) Um √≠ndice que s√≥ pode ser usado dentro de Stored Procedures ou Fun√ß√µes do banco de dados.",
            "B) Um √≠ndice que armazena o resultado de uma fun√ß√£o ou express√£o aplicada a uma ou mais colunas, em vez de armazenar os valores diretos das colunas.",
            "C) Um tipo especial de √≠ndice que automaticamente aplica fun√ß√µes comuns (como `UPPER`, `LOWER`) a todas as colunas de texto da tabela.",
            "D) Um √≠ndice que permite buscas `LIKE` com curinga no in√≠cio de forma eficiente em qualquer SGBD."
        ],
        "correct_index": 1,
        "explanation": "Um √≠ndice baseado em fun√ß√£o pr√©-calcula e armazena os resultados de uma express√£o (ex: `UPPER(coluna)`). Se a cl√°usula `WHERE` usar exatamente a mesma express√£o (ex: `WHERE UPPER(coluna) = 'VALOR'`), o banco pode usar esse √≠ndice eficientemente.  —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å ‚úÖ"
    },
    {
        "chapter": 3,
        "question": "Considere a consulta `SELECT * FROM usuarios WHERE UPPER(email) = 'USUARIO@EMAIL.COM'`. Qual √© a melhor abordagem para otimizar esta consulta se ela for frequente?",
        "options": [
            "A) Criar um √≠ndice padr√£o na coluna `email` e esperar que o SGBD o utilize.",
            "B) Evitar o uso da fun√ß√£o `UPPER` e garantir que os dados no `WHERE` correspondam ao case da coluna `email`.",
            "C) Criar um √≠ndice baseado na fun√ß√£o `UPPER(email)`.",
            "D) Usar `email LIKE 'usuario@email.com'` com a op√ß√£o `COLLATE` para ignorar case."
        ],
        "correct_index": 2,
        "explanation": "Para que uma fun√ß√£o aplicada a uma coluna na cl√°usula `WHERE` possa usar um √≠ndice diretamente, o √≠ndice deve ser criado sobre essa mesma express√£o funcional. Um √≠ndice em `UPPER(email)` atenderia perfeitamente √† condi√ß√£o. üõ†Ô∏è"
    },
    {
        "chapter": 3,
        "question": "Por que a consulta `WHERE nome_coluna LIKE '%meio%'` √© geralmente ineficiente, mesmo que `nome_coluna` esteja indexada?",
        "options": [
            "A) Porque o curinga `%` n√£o √© um caractere SQL padr√£o.",
            "B) Porque o banco de dados n√£o consegue usar a estrutura ordenada de um √≠ndice B-Tree para localizar diretamente um padr√£o que pode come√ßar em qualquer lugar da string.",
            "C) Porque `LIKE` sempre resulta em um Full Table Scan, independentemente dos curingas.",
            "D) Porque esse tipo de `LIKE` s√≥ funciona bem com Full-Text Search Indexes."
        ],
        "correct_index": 1,
        "explanation": "√çndices B-Tree s√£o como dicion√°rios ordenados. Se voc√™ n√£o sabe a primeira letra (ou primeiras letras) da palavra que procura (que √© o caso de `'%meio%'`), o dicion√°rio ordenado n√£o ajuda muito a encontr√°-la rapidamente. üìñ"
    },
    {
        "chapter": 3,
        "question": "Qual a principal desvantagem de usar √≠ndices baseados em fun√ß√£o?",
        "options": [
            "A) Eles s√£o sempre muito maiores que √≠ndices normais.",
            "B) Eles s√≥ podem ser usados em colunas do tipo num√©rico.",
            "C) A consulta deve usar *exatamente* a mesma fun√ß√£o/express√£o que foi usada na defini√ß√£o do √≠ndice para que ele seja utilizado.",
            "D) Eles impedem qualquer opera√ß√£o de `INSERT` ou `UPDATE` na tabela."
        ],
        "correct_index": 2,
        "explanation": "Para que um √≠ndice baseado em fun√ß√£o seja aproveitado, a express√£o na cl√°usula `WHERE` da consulta deve corresponder precisamente √† express√£o usada para criar o √≠ndice. Pequenas varia√ß√µes podem fazer com que o otimizador n√£o o utilize. üéØ"
    },
    {
        "chapter": 3,
        "question": "Para buscas case-insensitive (sem diferenciar mai√∫sculas de min√∫sculas) em uma coluna de texto, qual das seguintes N√ÉO √© uma t√©cnica comum de otimiza√ß√£o mencionada ou impl√≠cita no contexto do livro?",
        "options": [
            "A) Usar a fun√ß√£o `LOWER()` ou `UPPER()` em ambos os lados da compara√ß√£o e ter um √≠ndice na fun√ß√£o aplicada √† coluna (ex: `INDEX ON (LOWER(coluna))`).",
            "B) Usar um `COLLATE` espec√≠fico no n√≠vel da coluna ou da consulta que seja case-insensitive (se o SGBD suportar e o √≠ndice for compat√≠vel).",
            "C) Armazenar uma vers√£o normalizada da coluna (ex: toda em min√∫sculas) em uma coluna separada e indexar essa nova coluna.",
            "D) Aplicar a fun√ß√£o `LOWER()` ou `UPPER()` apenas no valor fornecido pelo usu√°rio no `WHERE`, deixando a coluna do banco intacta, para usar o √≠ndice padr√£o."
        ],
        "correct_index": 3,
        "explanation": "Aplicar a fun√ß√£o apenas no valor do usu√°rio (`WHERE coluna = LOWER('VALOR')`) n√£o torna a busca na coluna do banco SARGable para um √≠ndice padr√£o. A fun√ß√£o precisa estar na coluna do banco no `WHERE` para usar um √≠ndice funcional, ou o `COLLATE` deve cuidar disso, ou uma coluna normalizada deve ser usada. Aa ‚â† aA"
    },
    {
        "chapter": 3,
        "question": "Qual das alternativas descreve melhor o comportamento do otimizador de consultas quando encontra uma fun√ß√£o aplicada a uma coluna em um predicado `WHERE` (ex: `WHERE ANO(data_nascimento) = 2000`) e n√£o h√° um √≠ndice baseado nessa fun√ß√£o?",
        "options": [
            "A) O otimizador tentar√° reescrever a consulta para remover a fun√ß√£o automaticamente.",
            "B) O otimizador calcular√° a fun√ß√£o para cada linha da tabela e ent√£o comparar√° o resultado, resultando frequentemente em um Full Table Scan ou Index Full Scan.",
            "C) O otimizador retornar√° um erro, pois fun√ß√µes em predicados s√£o proibidas.",
            "D) O otimizador usar√° um √≠ndice padr√£o na coluna `data_nascimento` e aplicar√° a fun√ß√£o `ANO()` apenas aos valores lidos do √≠ndice."
        ],
        "correct_index": 1,
        "explanation": "Sem um √≠ndice na express√£o `ANO(data_nascimento)`, o banco de dados geralmente precisa aplicar a fun√ß√£o `ANO()` a cada valor da coluna `data_nascimento` na tabela (ou em todas as entradas de um √≠ndice, se fizer um Index Full Scan) antes de poder comparar com `2000`. Isso impede um 'seek' direto. üê¢"
    },
    {
        "chapter": 3,
        "question": "Se voc√™ precisa frequentemente buscar por `SUBSTRING(codigo_produto, 1, 3) = 'ABC'`, qual seria a forma mais eficiente de indexar para essa consulta?",
        "options": [
            "A) Um √≠ndice na coluna `codigo_produto` inteira.",
            "B) Um √≠ndice baseado na fun√ß√£o `SUBSTRING(codigo_produto, 1, 3)`.",
            "C) N√£o indexar e confiar no cache do banco.",
            "D) Um √≠ndice em outra coluna n√£o relacionada."
        ],
        "correct_index": 1,
        "explanation": "Criar um √≠ndice sobre a express√£o exata usada na consulta (`SUBSTRING(codigo_produto, 1, 3)`) permite que o banco utilize esse √≠ndice diretamente para encontrar as linhas correspondentes. ‚úÇÔ∏è"
    },
    {
        "chapter": 3,
        "question": "O uso de `OR` em uma cl√°usula `WHERE` combinando condi√ß√µes em colunas diferentes (ex: `WHERE status = 'A' OR prioridade = 1`) pode, √†s vezes, dificultar a otimiza√ß√£o com √≠ndices padr√µes. Qual √© uma alternativa que o livro pode sugerir para reescrever tal consulta, se aplic√°vel e se as condi√ß√µes forem independentes?",
        "options": [
            "A) Sempre usar `AND` em vez de `OR`.",
            "B) Usar `UNION ALL` para combinar os resultados de duas consultas separadas, cada uma otimizada para uma das condi√ß√µes do `OR` (assumindo que cada condi√ß√£o pode usar um √≠ndice diferente).",
            "C) Remover a cl√°usula `WHERE` e filtrar na aplica√ß√£o.",
            "D) Criar um √≠ndice multicoluna em `(status, prioridade)`."
        ],
        "correct_index": 1,
        "explanation": "Para `OR` em colunas diferentes, onde cada condi√ß√£o pode usar um √≠ndice diferente, reescrever com `UNION ALL` (e depois talvez `DISTINCT` se necess√°rio) pode permitir que cada parte da uni√£o use seu pr√≥prio √≠ndice otimizado. Um √≠ndice em `(status, prioridade)` n√£o ajudaria muito um `OR` simples. ‚à™"
    },
    {
        "chapter": 3,
        "question": "Qual √© o impacto principal de um predicado `WHERE data_coluna + INTERVAL '1 day' > CURRENT_DATE` em rela√ß√£o ao uso de um √≠ndice na `data_coluna`?",
        "options": [
            "A) Nenhum impacto, o √≠ndice ser√° usado normalmente.",
            "B) O √≠ndice n√£o pode ser usado porque h√° uma opera√ß√£o aritm√©tica (`+ INTERVAL '1 day'`) na coluna indexada.",
            "C) O √≠ndice ser√° usado, mas de forma menos eficiente.",
            "D) O banco de dados criar√° um √≠ndice tempor√°rio na express√£o."
        ],
        "correct_index": 1,
        "explanation": "Aplicar aritm√©tica ou fun√ß√µes a uma coluna no predicado `WHERE` geralmente torna o predicado non-SARGable para um √≠ndice padr√£o nessa coluna. Seria melhor reescrever como `data_coluna > CURRENT_DATE - INTERVAL '1 day'` para manter a coluna isolada. üóìÔ∏è"
    },
{
        "chapter": 4,
        "question": "Qual dos seguintes algoritmos de JOIN √© geralmente o mais eficiente quando uma tabela (a 'externa') √© pequena e a outra (a 'interna') √© grande e possui um √≠ndice na(s) coluna(s) de jun√ß√£o?",
        "options": [
            "A) Hash Join",
            "B) Sort Merge Join",
            "C) Nested Loops Join",
            "D) Cartesian Product (Cross Join)"
        ],
        "correct_index": 2,
        "explanation": "O Nested Loops Join itera sobre as linhas da tabela externa (menor) e, para cada uma, usa o √≠ndice da tabela interna (maior) para encontrar as linhas correspondentes rapidamente. ‚û∞"
    },
    {
        "chapter": 4,
        "question": "Em um `SELECT t1.*, t2.* FROM tabela1 t1 JOIN tabela2 t2 ON t1.id_fk = t2.id_pk`, qual coluna √© a candidata mais importante para ter um √≠ndice visando otimizar um Nested Loops Join?",
        "options": [
            "A) `t1.id_fk` (a coluna da chave estrangeira na tabela 'externa' da jun√ß√£o)",
            "B) `t2.id_pk` (a coluna da chave prim√°ria na tabela 'interna' da jun√ß√£o, que j√° √© indexada)",
            "C) Uma coluna n√£o relacionada ao JOIN em `tabela1`.",
            "D) Uma coluna n√£o relacionada ao JOIN em `tabela2`."
        ],
        "correct_index": 0,
        "explanation": "Para o Nested Loops Join, √© crucial que a coluna da tabela 'interna' na condi√ß√£o de jun√ß√£o seja indexada. Se `tabela1` for a tabela externa e `tabela2` a interna, um √≠ndice em `t2.id_pk` (que j√° existe) √© usado. Se `tabela2` for a externa e `tabela1` a interna, um √≠ndice em `t1.id_fk` seria essencial. No contexto da pergunta, o acesso eficiente √† tabela 'interna' (a segunda na ordem do loop) √© chave; se `t1` √© a externa, o √≠ndice em `t2.id_pk` (PK) √© usado. Se a ordem for invertida pelo otimizador, um √≠ndice em `t1.id_fk` seria vital. A pergunta sugere `t1 JOIN t2`, ent√£o `t2.id_pk` √© chave para o acesso √† `t2` (interna) para cada linha de `t1` (externa)."
    },
    {
        "chapter": 4,
        "question": "Quando um 'Hash Join' √© frequentemente escolhido pelo otimizador do banco de dados?",
        "options": [
            "A) Apenas quando ambas as tabelas envolvidas no JOIN s√£o muito pequenas.",
            "B) Para jun√ß√µes de igualdade (`=`), especialmente quando os conjuntos de dados s√£o grandes e n√£o h√° √≠ndices adequados para um Nested Loops Join, ou quando o otimizador estima que ser√° mais r√°pido.",
            "C) Para jun√ß√µes que envolvem condi√ß√µes de intervalo (`>`, `<`), pois o hash √© bom para ranges.",
            "D) Somente se as colunas de jun√ß√£o forem do tipo num√©rico inteiro."
        ],
        "correct_index": 1,
        "explanation": "O Hash Join constr√≥i uma tabela hash de uma das tabelas (geralmente a menor) na mem√≥ria e depois varre a outra tabela, procurando correspond√™ncias na tabela hash. √â eficiente para jun√ß√µes de igualdade em grandes volumes de dados e quando os √≠ndices n√£o favorecem outros m√©todos. üèóÔ∏è"
    },
    {
        "chapter": 4,
        "question": "Qual √© a principal caracter√≠stica de um 'Sort Merge Join'?",
        "options": [
            "A) Ele sempre requer que uma das tabelas caiba inteiramente na mem√≥ria.",
            "B) Ele primeiro ordena ambas as tabelas (ou os subconjuntos relevantes) pelas colunas de jun√ß√£o e depois mescla (merge) as linhas ordenadas.",
            "C) Ele n√£o precisa de condi√ß√µes de igualdade e funciona melhor com `LIKE`.",
            "D) Ele s√≥ funciona se as colunas de jun√ß√£o j√° forem chaves prim√°rias ordenadas."
        ],
        "correct_index": 1,
        "explanation": "O Sort Merge Join, como o nome sugere, envolve duas etapas principais: ordenar as tabelas pela(s) coluna(s) de jun√ß√£o (se j√° n√£o estiverem ordenadas por um √≠ndice) e depois fazer uma passagem linear pelas tabelas ordenadas para encontrar as correspond√™ncias. üìú+üìú=ü§ù"
    },
    {
        "chapter": 4,
        "question": "O que acontece se voc√™ fizer um JOIN entre duas tabelas sem uma cl√°usula `ON` (ou com uma condi√ß√£o `ON` que √© sempre verdadeira, como `1=1`)?",
        "options": [
            "A) O banco de dados retorna um erro de sintaxe.",
            "B) O banco de dados otimiza e assume uma jun√ß√£o pela chave prim√°ria e estrangeira mais √≥bvia.",
            "C) Ocorre um 'Produto Cartesiano' (Cross Join), onde cada linha da primeira tabela √© combinada com cada linha da segunda tabela, geralmente resultando em um conjunto de resultados muito grande e raramente desejado.",
            "D) O banco de dados realiza um `INNER JOIN` usando a primeira coluna de cada tabela."
        ],
        "correct_index": 2,
        "explanation": "A aus√™ncia de uma condi√ß√£o de jun√ß√£o significativa (ou uma condi√ß√£o sempre verdadeira) resulta em um Produto Cartesiano, que combina todas as linhas de uma tabela com todas as linhas da outra. Cuidado! ü§Ø"
    },
    {
        "chapter": 4,
        "question": "Em um `LEFT OUTER JOIN` de `TabelaA LEFT JOIN TabelaB ON TabelaA.id = TabelaB.fk_a`, o que acontece com as linhas da `TabelaA` que n√£o t√™m correspond√™ncia na `TabelaB`?",
        "options": [
            "A) Elas s√£o completamente omitidas do resultado.",
            "B) Elas s√£o inclu√≠das no resultado, e as colunas correspondentes da `TabelaB` s√£o preenchidas com valores `NULL`.",
            "C) A consulta resulta em um erro, pois todas as linhas da `TabelaA` devem ter correspond√™ncia.",
            "D) Elas s√£o inclu√≠das, e as colunas da `TabelaB` s√£o preenchidas com valores padr√£o da `TabelaB`."
        ],
        "correct_index": 1,
        "explanation": "A caracter√≠stica do `LEFT OUTER JOIN` √© que todas as linhas da tabela da esquerda (`TabelaA`) s√£o inclu√≠das no resultado. Se n√£o houver correspond√™ncia na tabela da direita (`TabelaB`), as colunas de `TabelaB` s√£o preenchidas com `NULL` para essas linhas. ‚¨ÖÔ∏è‚úîÔ∏è"
    },
    {
        "chapter": 4,
        "question": "Qual a principal recomenda√ß√£o do livro para a ordem das tabelas em um `JOIN` manual (se o SGBD n√£o reordenar)?",
        "options": [
            "A) Sempre listar a maior tabela primeiro.",
            "B) A ordem nunca importa, o otimizador sempre corrige.",
            "C) Para Nested Loops, listar a tabela que resulta no menor n√∫mero de itera√ß√µes no loop externo primeiro (geralmente a tabela menor ou a que retorna menos linhas ap√≥s filtros).",
            "D) Listar as tabelas em ordem alfab√©tica para clareza."
        ],
        "correct_index": 2,
        "explanation": "Embora muitos otimizadores tentem reordenar os joins, se voc√™ puder influenciar (ou estiver em um SGBD mais simples), para Nested Loops, ter a tabela menor (ou a que produz menos linhas ap√≥s os filtros iniciais) como a tabela 'externa' do loop √© geralmente mais eficiente. üìè"
    },
    {
        "chapter": 4,
        "question": "Usar `SELECT *` em uma consulta com m√∫ltiplos `JOIN`s pode ser problem√°tico para a performance por qu√™?",
        "options": [
            "A) Porque `*` √© uma palavra reservada que diminui a velocidade do parser SQL.",
            "B) Porque pode impedir 'Index-Only Scans' e aumentar o tr√°fego de dados, especialmente se muitas colunas n√£o s√£o realmente necess√°rias.",
            "C) Porque `SELECT *` n√£o √© compat√≠vel com a sintaxe `JOIN`.",
            "D) Porque sempre for√ßa o uso de um 'Cartesian Product'."
        ],
        "correct_index": 1,
        "explanation": "`SELECT *` busca todas as colunas de todas as tabelas envolvidas. Se algumas dessas colunas n√£o s√£o necess√°rias e poderiam ser obtidas de um √≠ndice (ou evitadas), o `SELECT *` for√ßa o acesso √† tabela e aumenta a quantidade de dados transferidos. üåü‚û°Ô∏èüì¶"
    },
    {
        "chapter": 4,
        "question": "O que √© um 'Join Predicate Pushdown'?",
        "options": [
            "A) Uma t√©cnica para adiar a avalia√ß√£o dos predicados de jun√ß√£o para o final da consulta.",
            "B) Uma otimiza√ß√£o onde o banco de dados tenta aplicar filtros (predicados `WHERE`) o mais cedo poss√≠vel, idealmente antes ou durante a opera√ß√£o de jun√ß√£o, para reduzir o n√∫mero de linhas a serem juntadas.",
            "C) Um tipo de JOIN que s√≥ funciona com predicados num√©ricos.",
            "D) Empurrar manualmente as tabelas na ordem correta na cl√°usula FROM."
        ],
        "correct_index": 1,
        "explanation": "Predicate Pushdown √© uma otimiza√ß√£o importante onde o SGBD aplica filtros o mais cedo poss√≠vel no plano de execu√ß√£o, muitas vezes 'empurrando-os' para dentro das opera√ß√µes de acesso √†s tabelas individuais antes mesmo que o join aconte√ßa, reduzindo o volume de dados a ser processado pelo join. üîΩ"
    },
    {
        "chapter": 4,
        "question": "Um `ANTI JOIN` (geralmente implementado com `NOT EXISTS` ou `NOT IN` ou `LEFT JOIN ... WHERE key IS NULL`) √© usado para qu√™?",
        "options": [
            "A) Encontrar todas as combina√ß√µes poss√≠veis entre duas tabelas.",
            "B) Encontrar linhas em uma tabela que N√ÉO t√™m correspond√™ncia em outra tabela.",
            "C) Juntar uma tabela com ela mesma (Self Join).",
            "D) Somar valores de colunas correspondentes em duas tabelas."
        ],
        "correct_index": 1,
        "explanation": "Um Anti Join √© usado para selecionar linhas da primeira tabela para as quais n√£o existem linhas correspondentes na segunda tabela, com base na condi√ß√£o de jun√ß√£o. üö´ü§ù"
    },
    {
        "chapter": 5,
        "question": "Qual √© o objetivo principal do 'clustering' (agrupamento) de dados em um banco de dados relacional?",
        "options": [
            "A) Aumentar o n√∫mero de conex√µes simult√¢neas que o banco pode suportar.",
            "B) Reduzir o espa√ßo total em disco ocupado pela base de dados.",
            "C) Armazenar fisicamente no disco as linhas que s√£o frequentemente acessadas juntas o mais pr√≥ximo poss√≠vel umas das outras, para minimizar o I/O.",
            "D) Garantir que todos os √≠ndices caibam inteiramente na mem√≥ria RAM."
        ],
        "correct_index": 2,
        "explanation": "O clustering visa melhorar a performance de I/O armazenando linhas relacionadas (ou linhas na mesma ordem de um √≠ndice frequentemente usado) pr√≥ximas no disco. Isso reduz o movimento da cabe√ßa do disco (para HDDs) e o n√∫mero de blocos diferentes a serem lidos. ÏòπÍ∏∞Ï¢ÖÍ∏∞"
    },
    {
        "chapter": 5,
        "question": "O que o 'fator de clusteriza√ß√£o' (index clustering factor) de um √≠ndice tipicamente indica?",
        "options": [
            "A) O n√∫mero de colunas no √≠ndice.",
            "B) Qu√£o bem a ordem das chaves no √≠ndice corresponde √† ordem f√≠sica das linhas na tabela principal (heap table). Um valor baixo √© melhor.",
            "C) A porcentagem de dados da tabela que est√° coberta pelo √≠ndice.",
            "D) A rapidez com que o √≠ndice pode ser reconstru√≠do."
        ],
        "correct_index": 1,
        "explanation": "Um fator de clusteriza√ß√£o baixo significa que as entradas sequenciais do √≠ndice tendem a apontar para linhas na tabela que est√£o no mesmo bloco de dados ou em blocos adjacentes. Um fator alto significa que o acesso √† tabela via √≠ndice ser√° mais aleat√≥rio e custoso. üìâüëç"
    },
    {
        "chapter": 5,
        "question": "O que √© um 'Index-Only Scan'?",
        "options": [
            "A) Uma varredura que l√™ apenas o primeiro n√≠vel de um √≠ndice B-Tree.",
            "B) Uma opera√ß√£o onde o banco de dados pode satisfazer completamente uma consulta (incluindo todas as colunas do SELECT, WHERE, ORDER BY, etc.) usando apenas os dados contidos em um √≠ndice, sem precisar acessar a tabela principal.",
            "C) Um tipo de scan que s√≥ funciona em tabelas organizadas por √≠ndice (IOTs).",
            "D) Uma varredura de √≠ndice que ignora os predicados da cl√°usula WHERE."
        ],
        "correct_index": 1,
        "explanation": "Se todas as informa√ß√µes que a consulta precisa est√£o dispon√≠veis no pr√≥prio √≠ndice (um 'covering index'), o banco pode evitar o acesso custoso √† tabela principal, resultando em um Index-Only Scan. ‚ú®"
    },
    {
        "chapter": 5,
        "question": "Qual √© uma das principais vantagens de uma 'Index-Organized Table' (IOT no Oracle) ou uma tabela com 'Clustered Index' (SQL Server, InnoDB no MySQL)?",
        "options": [
            "A) Elas sempre usam menos espa√ßo em disco do que tabelas heap com √≠ndices separados.",
            "B) As opera√ß√µes de INSERT s√£o sempre mais r√°pidas nelas.",
            "C) O acesso aos dados pela chave prim√°ria (que define a organiza√ß√£o da tabela) √© muito r√°pido, pois os dados da linha residem diretamente na estrutura do √≠ndice.",
            "D) Elas permitem um n√∫mero ilimitado de √≠ndices secund√°rios sem perda de performance."
        ],
        "correct_index": 2,
        "explanation": "Em IOTs/tabelas com √≠ndice clusterizado, a tabela √© o √≠ndice prim√°rio. Portanto, o acesso via chave prim√°ria √© direto e n√£o requer um 'lookup' adicional para a tabela, pois os dados j√° est√£o l√°. üè†"
    },
    {
        "chapter": 5,
        "question": "Qual √© uma desvantagem significativa dos √≠ndices secund√°rios em Index-Organized Tables (IOTs) ou tabelas com Clustered Index?",
        "options": [
            "A) √çndices secund√°rios n√£o s√£o permitidos nesse tipo de tabela.",
            "B) Eles tendem a ser muito pequenos, o que os torna ineficientes.",
            "C) Eles geralmente armazenam a(s) chave(s) do √≠ndice clusterizado como ponteiro para a linha, o que pode levar a buscas duplas em √≠ndice (uma no secund√°rio, outra no clusterizado) e torn√°-los maiores se a chave clusterizada for grande.",
            "D) Eles s√≥ podem indexar colunas num√©ricas."
        ],
        "correct_index": 2,
        "explanation": "Como n√£o h√° um ROWID est√°vel para a heap table (pois ela n√£o existe separadamente), os √≠ndices secund√°rios precisam apontar para a linha usando a chave do √≠ndice prim√°rio/clusterizado. Isso pode levar a uma busca adicional e aumentar o tamanho dos √≠ndices secund√°rios. üòü"
    },
    {
        "chapter": 5,
        "question": "Para que tipo de consulta um 'Index-Only Scan' √© particularmente ben√©fico?",
        "options": [
            "A) Consultas que atualizam muitas colunas da tabela.",
            "B) Consultas que selecionam poucas colunas, e essas colunas (junto com as do WHERE e ORDER BY) est√£o todas presentes em um mesmo √≠ndice.",
            "C) Consultas que sempre fazem `SELECT *`.",
            "D) Consultas que n√£o possuem cl√°usula WHERE."
        ],
        "correct_index": 1,
        "explanation": "Se voc√™ precisa de poucas colunas e consegue colocar todas elas em um √≠ndice (incluindo as do WHERE, etc.), o banco pode evitar o acesso √† tabela, economizando I/O. `SELECT *` geralmente impede Index-Only Scans. üéØ"
    },
    {
        "chapter": 5,
        "question": "O comando `CLUSTER` no PostgreSQL tem qual efeito principal?",
        "options": [
            "A) Cria um √≠ndice clusterizado que √© mantido automaticamente pelo PostgreSQL, similar ao SQL Server.",
            "B) Reordena fisicamente a tabela no disco de acordo com a ordem de um √≠ndice especificado, mas essa ordem n√£o √© mantida automaticamente para inser√ß√µes e atualiza√ß√µes futuras (√© uma opera√ß√£o √∫nica).",
            "C) Conecta m√∫ltiplos servidores PostgreSQL em um cluster para alta disponibilidade.",
            "D) Comprime os dados da tabela para economizar espa√ßo."
        ],
        "correct_index": 1,
        "explanation": "O comando `CLUSTER` no PostgreSQL reescreve a tabela baseada na ordem de um √≠ndice. √â uma opera√ß√£o one-time; a ordem n√£o √© mantida automaticamente depois disso. üîÑ"
    },
    {
        "chapter": 5,
        "question": "No MySQL com InnoDB, como as tabelas s√£o armazenadas por padr√£o?",
        "options": [
            "A) Como heap tables, com um √≠ndice prim√°rio n√£o clusterizado opcional.",
            "B) Sempre como Index-Organized Tables (IOTs) baseadas na chave prim√°ria (√≠ndice clusterizado). Se nenhuma PK √© definida, o InnoDB escolhe uma ou cria uma oculta.",
            "C) Em arquivos CSV simples para facilitar a importa√ß√£o/exporta√ß√£o.",
            "D) O DBA escolhe entre heap table e IOT no momento da cria√ß√£o de cada tabela."
        ],
        "correct_index": 1,
        "explanation": "O InnoDB no MySQL organiza todas as tabelas como √≠ndices clusterizados, usando a chave prim√°ria. Se n√£o houver PK, ele procura o primeiro √≠ndice UNIQUE NOT NULL ou cria uma chave oculta.  InnoDB ‚ù§Ô∏è Clustered Index."
    },
    {
        "chapter": 5,
        "question": "Qual √© a principal motiva√ß√£o para se preocupar com o 'clustering' de dados ou usar 'Index-Only Scans'?",
        "options": [
            "A) Reduzir o uso de CPU do servidor de banco de dados.",
            "B) Minimizar o n√∫mero de opera√ß√µes de I/O de disco, que s√£o geralmente as opera√ß√µes mais lentas em um sistema de banco de dados.",
            "C) Simplificar a sintaxe das consultas SQL.",
            "D) Aumentar a seguran√ßa dos dados armazenados."
        ],
        "correct_index": 1,
        "explanation": "Tanto o agrupamento de dados quanto os Index-Only Scans visam reduzir a quantidade de leituras de disco necess√°rias para satisfazer uma consulta, pois o I/O de disco √© um dos maiores gargalos de performance. üöÄ"
    },
    {
        "chapter": 5,
        "question": "Se um √≠ndice secund√°rio em uma tabela com √≠ndice clusterizado (ex: InnoDB) cont√©m as colunas da chave clusterizada, para qual tipo de consulta esse √≠ndice secund√°rio poderia se tornar 'covering' (permitir um index-only scan) mesmo sem incluir todas as colunas do SELECT?",
        "options": [
            "A) Nunca, um √≠ndice secund√°rio n√£o pode ser 'covering' em tabelas clusterizadas.",
            "B) Se a consulta selecionar apenas colunas que fazem parte do pr√≥prio √≠ndice secund√°rio OU colunas que fazem parte da chave clusterizada (que tamb√©m est√£o no √≠ndice secund√°rio).",
            "C) Apenas se o √≠ndice secund√°rio for tamb√©m a chave prim√°ria.",
            "D) Apenas para consultas que usam fun√ß√µes de agrega√ß√£o."
        ],
        "correct_index": 1,
        "explanation": "Como os √≠ndices secund√°rios em tabelas clusterizadas (como no InnoDB) incluem as colunas da chave prim√°ria (clusterizada), se sua consulta precisa apenas de colunas do √≠ndice secund√°rio e/ou colunas da PK, o banco pode satisfazer a consulta lendo apenas o √≠ndice secund√°rio. üëç"
    },
{
        "chapter": 6,
        "question": "Qual √© o 'terceiro poder da indexa√ß√£o' (third power of indexing) mencionado no livro em rela√ß√£o √† cl√°usula `ORDER BY`?",
        "options": [
            "A) A capacidade de um √≠ndice ordenar dados em mem√≥ria mais rapidamente do que no disco.",
            "B) A capacidade de um √≠ndice ser lido em ambas as dire√ß√µes (ascendente e descendente) para satisfazer diferentes ordens.",
            "C) A capacidade de um √≠ndice fornecer dados j√° ordenados, permitindo que a opera√ß√£o `ORDER BY` seja 'pipelined' (em pipeline), ou seja, o banco pode come√ßar a retornar as primeiras linhas ordenadas sem processar todo o conjunto de dados.",
            "D) A capacidade de um √≠ndice for√ßar uma ordena√ß√£o espec√≠fica, mesmo que o usu√°rio pe√ßa outra."
        ],
        "correct_index": 2,
        "explanation": "Se um √≠ndice pode satisfazer a cl√°usula `ORDER BY`, o banco de dados n√£o precisa realizar uma opera√ß√£o de sort separada e custosa. Ele pode ler os dados j√° ordenados do √≠ndice e come√ßar a enviar as primeiras linhas imediatamente (execu√ß√£o em pipeline). üöö"
    },
    {
        "chapter": 6,
        "question": "Para que uma consulta com `ORDER BY col_a, col_b` evite uma opera√ß√£o de `SORT` expl√≠cita, qual das seguintes condi√ß√µes de √≠ndice √© a mais ideal?",
        "options": [
            "A) Um √≠ndice em `(col_b, col_a)`.",
            "B) Um √≠ndice em `(col_a)` e outro √≠ndice separado em `(col_b)`.",
            "C) Um √≠ndice multicoluna em `(col_a, col_b)`.",
            "D) Um √≠ndice em qualquer coluna da tabela, desde que seja B-Tree."
        ],
        "correct_index": 2,
        "explanation": "Para que o `ORDER BY` seja satisfeito diretamente pelo √≠ndice, o √≠ndice deve conter as colunas da cl√°usula `ORDER BY` na mesma ordem (ou em uma ordem que o banco possa usar, como a inversa) e as condi√ß√µes da cl√°usula `WHERE` devem permitir o uso dessa ordem. üéº"
    },
    {
        "chapter": 6,
        "question": "Se voc√™ tem um √≠ndice em `(data_evento ASC, prioridade ASC)` e sua consulta √© `SELECT * FROM eventos WHERE data_evento = '2024-05-23' ORDER BY prioridade ASC`, o banco de dados provavelmente evitar√° um sort expl√≠cito para `prioridade`?",
        "options": [
            "A) N√£o, porque `prioridade` n√£o √© a primeira coluna do √≠ndice.",
            "B) Sim, porque a condi√ß√£o de igualdade em `data_evento` fixa a primeira parte do √≠ndice, e as entradas para essa data j√° estar√£o ordenadas por `prioridade` dentro do √≠ndice.",
            "C) Apenas se `prioridade` for um n√∫mero inteiro.",
            "D) N√£o, porque `ORDER BY` com m√∫ltiplas colunas sempre requer sort."
        ],
        "correct_index": 1,
        "explanation": "Quando a(s) primeira(s) coluna(s) de um √≠ndice multicoluna s√£o fixadas por condi√ß√µes de igualdade no `WHERE`, as colunas subsequentes do √≠ndice podem ser usadas para satisfazer o `ORDER BY` para o subconjunto resultante. ‚úÖ"
    },
    {
        "chapter": 6,
        "question": "Um banco de dados pode usar um √≠ndice definido como `(col_x ASC, col_y ASC)` para satisfazer uma consulta com `ORDER BY col_x DESC, col_y DESC` sem um sort expl√≠cito?",
        "options": [
            "A) N√£o, as dire√ß√µes `ASC`/`DESC` devem corresponder exatamente.",
            "B) Sim, muitos SGBDs podem ler um √≠ndice B-Tree em ambas as dire√ß√µes (para frente e para tr√°s).",
            "C) Apenas se `col_x` e `col_y` forem num√©ricas.",
            "D) Apenas se o √≠ndice for do tipo Hash."
        ],
        "correct_index": 1,
        "explanation": "A maioria dos SGBDs modernos pode realizar um 'Index Backward Scan' (varredura de √≠ndice para tr√°s), permitindo que um √≠ndice `ASC` seja usado para uma ordena√ß√£o `DESC` (e vice-versa), desde que todas as colunas na ordena√ß√£o tenham a dire√ß√£o invertida de forma consistente. ‚è™"
    },
    {
        "chapter": 6,
        "question": "Se uma consulta requer `ORDER BY col_A ASC, col_B DESC` (ordens mistas), o que √© necess√°rio para que um √≠ndice evite o sort?",
        "options": [
            "A) Um √≠ndice em `(col_A ASC, col_B ASC)` √© suficiente, o banco ajusta.",
            "B) Um √≠ndice em `(col_B DESC, col_A ASC)` √© a melhor op√ß√£o.",
            "C) O √≠ndice deve ser definido com as mesmas dire√ß√µes de ordena√ß√£o especificadas no `ORDER BY`, ou seja, `CREATE INDEX ... ON tabela (col_A ASC, col_B DESC)`.",
            "D) √â imposs√≠vel evitar o sort com ordens mistas."
        ],
        "correct_index": 2,
        "explanation": "Para ordens mistas no `ORDER BY`, o banco n√£o pode simplesmente ler um √≠ndice padr√£o (todo `ASC` ou todo `DESC`) para frente ou para tr√°s. O √≠ndice precisa ser criado explicitamente com essas ordens mistas para ser usado diretamente. üîÑ"
    },
    {
        "chapter": 6,
        "question": "Qual dos dois principais algoritmos de `GROUP BY` pode se beneficiar diretamente de um √≠ndice para evitar uma ordena√ß√£o pr√©via dos dados?",
        "options": [
            "A) O algoritmo 'Hash Aggregate'.",
            "B) O algoritmo 'Sort Aggregate' (ou 'Stream Aggregate').",
            "C) Ambos os algoritmos se beneficiam igualmente de qualquer √≠ndice.",
            "D) Nenhum algoritmo de `GROUP BY` usa √≠ndices, eles sempre ordenam ou usam hash em todos os dados."
        ],
        "correct_index": 1,
        "explanation": "O algoritmo 'Sort Aggregate' primeiro ordena os dados pelas colunas do `GROUP BY` e depois agrupa. Se um √≠ndice j√° fornece os dados nessa ordem (devido a uma cl√°usula `WHERE` adequada), a etapa de sort pode ser pulada (o plano pode mostrar 'NOSORT' ou simplesmente n√£o ter um passo de sort antes da agrega√ß√£o). ÂàÜÈ°û‚û°Ô∏è‚ûï"
    },
    {
        "chapter": 6,
        "question": "Para que um `GROUP BY col_categoria` seja otimizado por um √≠ndice em `(col_categoria)`, qual condi√ß√£o na cl√°usula `WHERE` seria mais favor√°vel?",
        "options": [
            "A) Nenhuma condi√ß√£o `WHERE`.",
            "B) `WHERE col_outra_coisa = 'valor'`, onde `col_outra_coisa` n√£o est√° no √≠ndice.",
            "C) `WHERE col_categoria LIKE '%abc%'`.",
            "D) `WHERE col_categoria BETWEEN 'A' AND 'C'`."
        ],
        "correct_index": 3,
        "explanation": "Se a cl√°usula `WHERE` permite uma varredura de intervalo (range scan) no √≠ndice `(col_categoria)` de forma que os dados j√° saiam agrupados ou ordenados por `col_categoria`, o `GROUP BY` pode ser mais eficiente. Uma condi√ß√£o de igualdade ou um range pequeno na coluna do `GROUP BY` √© ideal. üëç"
    },
    {
        "chapter": 6,
        "question": "O que significa um `GROUP BY` 'pipelined' (em pipeline)?",
        "options": [
            "A) Que o `GROUP BY` √© executado em paralelo usando m√∫ltiplos pipelines de CPU.",
            "B) Que o banco de dados pode come√ßar a processar e agregar os grupos √† medida que l√™ os dados (geralmente de um √≠ndice ordenado), sem precisar armazenar e ordenar todo o conjunto de dados primeiro.",
            "C) Que os resultados do `GROUP BY` s√£o enviados para outra consulta atrav√©s de um pipeline.",
            "D) Um `GROUP BY` que usa apenas fun√ß√µes de agrega√ß√£o que suportam pipeline."
        ],
        "correct_index": 1,
        "explanation": "Um `GROUP BY` em pipeline, assim como um `ORDER BY` em pipeline, significa que o banco n√£o precisa de uma etapa intermedi√°ria massiva de ordena√ß√£o ou hashing de todo o conjunto de dados antes de come√ßar a produzir os grupos agregados. Isso √© poss√≠vel se um √≠ndice fornecer os dados na ordem de agrupamento. üíß‚û°Ô∏è‚û°Ô∏è‚û°Ô∏è"
    },
    {
        "chapter": 6,
        "question": "Se um √≠ndice √© `(A ASC, B DESC)`, qual `ORDER BY` N√ÉO pode usar este √≠ndice diretamente para evitar um sort (sem ler o √≠ndice ao contr√°rio)?",
        "options": [
            "A) `ORDER BY A ASC, B DESC`",
            "B) `ORDER BY A ASC` (se o `WHERE` fixar A ou permitir um range scan em A)",
            "C) `ORDER BY A DESC, B ASC`",
            "D) `ORDER BY A ASC, B ASC`"
        ],
        "correct_index": 3,
        "explanation": "O √≠ndice `(A ASC, B DESC)` fornece uma ordem espec√≠fica. `ORDER BY A ASC, B ASC` tem uma dire√ß√£o diferente para B, exigindo um novo sort. A op√ß√£o C exigiria ler o √≠ndice ao contr√°rio. Op√ß√£o A e B (parcialmente) podem usar o √≠ndice. üöß"
    },
    {
        "chapter": 6,
        "question": "Al√©m de `ORDER BY` e `GROUP BY`, qual outra opera√ß√£o SQL pode se beneficiar de um √≠ndice para evitar uma ordena√ß√£o expl√≠cita dos dados?",
        "options": [
            "A) `UNION ALL`",
            "B) `SELECT COUNT(*)` sem `WHERE`.",
            "C) `DISTINCT` (ou `SELECT DISTINCT ...`)",
            "D) Subconsultas correlacionadas."
        ],
        "correct_index": 2,
        "explanation": "A opera√ß√£o `DISTINCT` precisa identificar valores √∫nicos, o que √© frequentemente feito ordenando os dados e depois removendo duplicatas adjacentes. Se um √≠ndice fornecer os dados j√° ordenados, essa etapa de sort pode ser evitada. ‚ú®"
    },
    {
        "chapter": 7,
        "question": "Qual √© o principal problema de performance da pagina√ß√£o usando `OFFSET` para buscar p√°ginas distantes do in√≠cio (ex: `LIMIT 10 OFFSET 50000`)?",
        "options": [
            "A) `OFFSET` sempre for√ßa o banco a usar um √≠ndice menos eficiente.",
            "B) O banco de dados precisa identificar, ordenar e depois *descartar* todas as N linhas do offset antes de poder retornar as M linhas da p√°gina desejada, o que √© custoso para N grande.",
            "C) `OFFSET` n√£o √© uma cl√°usula SQL padr√£o e tem implementa√ß√µes inconsistentes.",
            "D) `OFFSET` consome uma quantidade excessiva de espa√ßo em disco tempor√°rio, independentemente do n√∫mero de linhas."
        ],
        "correct_index": 1,
        "explanation": "O `OFFSET` grande faz com que o banco de dados processe (busque, ordene e conte) muitas linhas que ser√£o simplesmente descartadas, levando a uma degrada√ß√£o de performance proporcional ao valor do offset. üêå"
    },
    {
        "chapter": 7,
        "question": "Qual √© a abordagem fundamental da 'Keyset Pagination' (Pagina√ß√£o por Conjunto de Chaves ou Seek Method)?",
        "options": [
            "A) Usar a cl√°usula `OFFSET` de forma mais otimizada com um c√°lculo de 'keyset'.",
            "B) Armazenar em cache todas as p√°ginas na mem√≥ria da aplica√ß√£o.",
            "C) Usar os valores da(s) coluna(s) de ordena√ß√£o do √∫ltimo item da p√°gina anterior para construir uma cl√°usula `WHERE` que busque diretamente o in√≠cio da pr√≥xima p√°gina.",
            "D) Pr√©-calcular e armazenar os ROWIDs de cada linha de cada p√°gina poss√≠vel."
        ],
        "correct_index": 2,
        "explanation": "A Keyset Pagination evita o `OFFSET` usando uma condi√ß√£o `WHERE` baseada nos valores de ordena√ß√£o do √∫ltimo registro da p√°gina anterior para 'saltar' diretamente para o pr√≥ximo conjunto de registros, usando um √≠ndice. üîë"
    },
    {
        "chapter": 7,
        "question": "Para que a Keyset Pagination funcione corretamente e de forma eficiente, quais s√£o os pr√©-requisitos importantes para a cl√°usula `ORDER BY` e os √≠ndices?",
        "options": [
            "A) O `ORDER BY` deve usar apenas uma coluna e essa coluna n√£o pode ser indexada.",
            "B) O `ORDER BY` deve garantir uma ordem est√°vel e √∫nica (frequentemente adicionando a chave prim√°ria como desempate), e deve haver um √≠ndice que suporte essa ordena√ß√£o.",
            "C) N√£o √© necess√°rio `ORDER BY`, pois o Keyset Pagination usa a ordem natural da tabela.",
            "D) Apenas um √≠ndice do tipo Hash pode ser usado com Keyset Pagination."
        ],
        "correct_index": 1,
        "explanation": "Uma ordena√ß√£o est√°vel e √∫nica √© crucial para n√£o pular ou repetir registros. Um √≠ndice que corresponda a essa ordena√ß√£o √© essencial para que o 'seek' (busca) para o pr√≥ximo conjunto de chaves seja eficiente. üîí"
    },
    {
        "chapter": 7,
        "question": "Qual √© uma limita√ß√£o comum da Keyset Pagination em termos de funcionalidade da interface do usu√°rio (UI)?",
        "options": [
            "A) Ela n√£o funciona bem com ordena√ß√£o descendente (`DESC`).",
            "B) √â mais lenta que `OFFSET` para as primeiras p√°ginas.",
            "C) Torna dif√≠cil ou ineficiente para o usu√°rio pular diretamente para uma p√°gina arbitr√°ria (ex: ir da p√°gina 1 para a p√°gina 50) sem conhecer os 'cursores' intermedi√°rios.",
            "D) Ela n√£o pode ser usada com cl√°usulas `WHERE` complexas."
        ],
        "correct_index": 2,
        "explanation": "Como a Keyset Pagination depende dos valores da p√°gina anterior para buscar a pr√≥xima, ela √© inerentemente sequencial ('Pr√≥ximo'/'Anterior'). Implementar um salto direto para um n√∫mero de p√°gina espec√≠fico √© mais complexo. üö∂‚û°Ô∏èüö∂"
    },
    {
        "chapter": 7,
        "question": "Como a fun√ß√£o de janela `ROW_NUMBER() OVER (ORDER BY ...)` √© usada para implementar pagina√ß√£o?",
        "options": [
            "A) Ela substitui a cl√°usula `OFFSET` nativamente, tornando-a mais r√°pida.",
            "B) Ela √© usada em uma subconsulta (ou CTE) para atribuir um n√∫mero sequencial a cada linha baseado na ordena√ß√£o, e a consulta externa filtra por um intervalo desses n√∫meros de linha.",
            "C) Ela s√≥ pode ser usada para contar o n√∫mero total de p√°ginas, n√£o para buscar os dados da p√°gina.",
            "D) Ela cria um √≠ndice tempor√°rio baseado na numera√ß√£o das linhas."
        ],
        "correct_index": 1,
        "explanation": "Primeiro, todas as linhas (ou as que passam por um filtro inicial) s√£o numeradas usando `ROW_NUMBER()`. Depois, uma consulta externa seleciona as linhas onde o n√∫mero gerado est√° dentro do intervalo da p√°gina desejada (ex: `WHERE rn BETWEEN 21 AND 30`). üî¢"
    },
    {
        "chapter": 7,
        "question": "Comparando a pagina√ß√£o com `ROW_NUMBER()` e a Keyset Pagination para buscar p√°ginas muito distantes do in√≠cio, qual geralmente oferece melhor performance?",
        "options": [
            "A) `ROW_NUMBER()` √© sempre mais r√°pido porque usa fun√ß√µes de janela otimizadas.",
            "B) Ambas t√™m performance id√™ntica em todos os cen√°rios.",
            "C) Keyset Pagination √© geralmente mais perform√°tica porque evita a necessidade de processar/numerar todas as linhas at√© a p√°gina desejada; ela 'salta' usando um √≠ndice.",
            "D) Depende apenas do n√∫mero de colunas selecionadas."
        ],
        "correct_index": 2,
        "explanation": "Keyset Pagination tende a ser superior para pagina√ß√£o profunda, pois o custo √© relativamente constante por p√°gina. `ROW_NUMBER()` ainda precisa, conceitualmente, processar ou enumerar todas as linhas at√© o final da janela da p√°gina desejada. üöÄ vs üö∂‚Äç‚ôÄÔ∏è...üö∂‚Äç‚ôÇÔ∏è"
    },
    {
        "chapter": 7,
        "question": "Se uma consulta de pagina√ß√£o usa `LIMIT N` (ou `Workspace FIRST N ROWS`) e tem uma cl√°usula `ORDER BY`, por que √© crucial que o `ORDER BY` seja suportado por um √≠ndice?",
        "options": [
            "A) Para garantir que N seja sempre um n√∫mero par.",
            "B) Para que o banco de dados possa ler os dados j√° ordenados e parar de buscar assim que N linhas forem encontradas, evitando um 'Sort Limited' (ordenar muitos dados para pegar poucos).",
            "C) Porque `LIMIT` s√≥ funciona sintaticamente se houver um `ORDER BY` indexado.",
            "D) Para reduzir o tamanho do √≠ndice, tornando o `LIMIT` mais r√°pido."
        ],
        "correct_index": 1,
        "explanation": "Com um `ORDER BY` indexado, o SGBD pode pegar as N primeiras linhas diretamente da ordem do √≠ndice e parar. Sem isso, ele pode ter que buscar um grande conjunto de dados, orden√°-lo completamente (opera√ß√£o custosa), e s√≥ ent√£o aplicar o `LIMIT`. üõë"
    },
    {
        "chapter": 7,
        "question": "Para construir a cl√°usula `WHERE` da Keyset Pagination com `ORDER BY col_data DESC, col_id ASC`, se a √∫ltima linha da p√°gina anterior foi `(data_X, id_Y)`, qual l√≥gica √© a correta para buscar a pr√≥xima p√°gina?",
        "options": [
            "A) `WHERE (col_data > data_X) OR (col_data = data_X AND col_id < id_Y)`",
            "B) `WHERE (col_data < data_X) OR (col_data = data_X AND col_id > id_Y)`",
            "C) `WHERE col_data < data_X AND col_id > id_Y`",
            "D) `WHERE col_data > data_X AND col_id < id_Y`"
        ],
        "correct_index": 1,
        "explanation": "Como `col_data` √© `DESC`, queremos datas 'menores' (mais antigas). Se a data for igual, como `col_id` √© `ASC`, queremos IDs 'maiores' para prosseguir. A forma `(col_data, col_id) < (data_X, id_Y)` em alguns SGBDs pode precisar ser escrita explicitamente como a op√ß√£o B para ordens mistas. üëáüîº"
    },
    {
        "chapter": 7,
        "question": "Qual tipo de retorno do Spring Data JPA (`Page<T>` vs `Slice<T>`) pode ajudar a otimizar a pagina√ß√£o se a contagem total de elementos for custosa e n√£o necess√°ria para cada requisi√ß√£o?",
        "options": [
            "A) `Page<T>`, pois sempre inclui a contagem de forma otimizada.",
            "B) `Slice<T>`, pois n√£o executa a consulta de `COUNT(*)` para obter o total de elementos/p√°ginas, apenas indica se h√° uma pr√≥xima 'fatia'.",
            "C) Ambos s√£o id√™nticos em termos das queries executadas.",
            "D) Nenhum deles, a otimiza√ß√£o de contagem deve ser feita manualmente."
        ],
        "correct_index": 1,
        "explanation": "`Slice<T>` √© uma otimiza√ß√£o para cen√°rios como 'scroll infinito' onde voc√™ s√≥ precisa saber se h√° mais dados para carregar, evitando a query de `COUNT(*)` que `Page<T>` executa. üçï"
    },
    {
        "chapter": 7,
        "question": "Ao implementar pagina√ß√£o, qual √© o principal benef√≠cio de usar uma 'coluna de desempate' √∫nica (como a chave prim√°ria) no final da cl√°usula `ORDER BY`?",
        "options": [
            "A) Torna a consulta mais curta e f√°cil de ler.",
            "B) Garante uma ordem est√°vel e √∫nica, prevenindo que registros sejam pulados ou repetidos entre as p√°ginas, especialmente se as colunas prim√°rias de ordena√ß√£o tiverem valores duplicados.",
            "C) Permite que o banco de dados use sempre um 'Index-Only Scan'.",
            "D) Melhora a performance do `COUNT(*)`."
        ],
        "correct_index": 1,
        "explanation": "Se as colunas principais do `ORDER BY` podem ter valores iguais, a ordem das linhas com esses valores iguais pode ser indeterminada. Adicionar uma coluna √∫nica (como a PK) no final do `ORDER BY` garante que a ordem total seja sempre a mesma, o que √© crucial para a corretude da Keyset Pagination. ‚öì"
    },
{
        "chapter": 8,
        "question": "Qual √© o principal impacto nos √≠ndices quando voc√™ executa um `INSERT` em uma tabela com m√∫ltiplos √≠ndices?",
        "options": [
            "A) Nenhum, pois `INSERT`s s√≥ afetam os dados da tabela principal e os √≠ndices s√£o atualizados em background sem custo.",
            "B) Apenas o √≠ndice prim√°rio √© atualizado; os demais s√£o marcados como 'dirty' para uma atualiza√ß√£o posterior.",
            "C) Uma nova entrada deve ser adicionada em CADA um dos √≠ndices da tabela, al√©m da inser√ß√£o na pr√≥pria tabela.",
            "D) Os √≠ndices s√£o temporariamente ignorados para acelerar a inser√ß√£o e reconstru√≠dos depois."
        ],
        "correct_index": 2,
        "explanation": "Para cada linha inserida na tabela, o banco de dados precisa adicionar uma entrada correspondente em todos os √≠ndices existentes nessa tabela. Isso multiplica o trabalho de escrita. ‚úçÔ∏è‚û°Ô∏èüìùüìùüìù"
    },
    {
        "chapter": 8,
        "question": "Ao fazer um `UPDATE` em uma linha, qual cen√°rio geralmente resulta no MAIOR custo de performance relacionado a √≠ndices?",
        "options": [
            "A) Atualizar uma coluna que n√£o faz parte de nenhum √≠ndice.",
            "B) Atualizar uma coluna que faz parte de um ou mais √≠ndices.",
            "C) O custo √© sempre o mesmo, pois o `UPDATE` reescreve a linha inteira na tabela.",
            "D) Atualizar a chave prim√°ria, mas apenas se ela n√£o for referenciada por chaves estrangeiras."
        ],
        "correct_index": 1,
        "explanation": "Atualizar uma coluna indexada √© custoso porque o banco precisa, efetivamente, tratar como um 'delete' da entrada antiga do √≠ndice e um 'insert' da nova entrada, para cada √≠ndice que cont√©m a coluna modificada. üóëÔ∏è‚ûï"
    },
    {
        "chapter": 8,
        "question": "Qual √© a principal vantagem de usar 'Bulk Inserts' (inser√ß√µes em lote) em vez de inserir uma linha por vez em transa√ß√µes separadas?",
        "options": [
            "A) Garante que cada linha inserida seja validada individualmente por constraints, tornando o processo mais seguro.",
            "B) Reduz o overhead de comunica√ß√£o com o banco, o overhead de transa√ß√£o, e permite que o banco otimize as atualiza√ß√µes dos √≠ndices para o lote de linhas.",
            "C) Ocupa menos espa√ßo no log de transa√ß√µes porque apenas a primeira e a √∫ltima linha s√£o logadas.",
            "D) Melhora a legibilidade do c√≥digo SQL, mas n√£o afeta a performance."
        ],
        "correct_index": 1,
        "explanation": "Inser√ß√µes em lote minimizam idas e vindas ao banco e permitem otimiza√ß√µes internas na atualiza√ß√£o de √≠ndices, tornando o processo muito mais eficiente para m√∫ltiplas linhas. üööüí®"
    },
    {
        "chapter": 8,
        "question": "Em tabelas com √≠ndice clusterizado (ex: InnoDB no MySQL, SQL Server) ou Index-Organized Tables (Oracle), qual pr√°tica de inser√ß√£o pode ajudar a minimizar 'page splits'?",
        "options": [
            "A) Inserir dados em uma ordem completamente aleat√≥ria para distribuir a carga.",
            "B) Inserir dados em uma ordem que se aproxime da ordem da chave do √≠ndice clusterizado.",
            "C) Sempre inserir dados usando a cl√°usula `WITH (NOLOCK)`.",
            "D) Inserir cada linha em uma transa√ß√£o separada."
        ],
        "correct_index": 1,
        "explanation": "Inserir dados em uma ordem que corresponda √† chave de clusteriza√ß√£o permite que as novas linhas sejam adicionadas de forma mais sequencial nas p√°ginas de dados, reduzindo a necessidade de dividir p√°ginas existentes, o que √© custoso. ‚û°Ô∏èüìÑ‚û°Ô∏èüìÑ"
    },
    {
        "chapter": 8,
        "question": "Para otimizar `UPDATE` e `DELETE`, qual √© a recomenda√ß√£o mais crucial em rela√ß√£o √† cl√°usula `WHERE`?",
        "options": [
            "A) Evitar o uso da cl√°usula `WHERE` para garantir que todas as linhas sejam processadas consistentemente.",
            "B) Usar fun√ß√µes complexas na cl√°usula `WHERE` para flexibilidade.",
            "C) Garantir que a cl√°usula `WHERE` possa utilizar eficientemente um √≠ndice para localizar rapidamente as linhas a serem modificadas ou deletadas.",
            "D) Sempre usar subconsultas na cl√°usula `WHERE` para `UPDATE` e `DELETE`."
        ],
        "correct_index": 2,
        "explanation": "Assim como nos `SELECT`s, a cl√°usula `WHERE` de `UPDATE`s e `DELETE`s deve ser SARGable e usar colunas indexadas para que o banco encontre as linhas alvo rapidamente, evitando full table scans. üéØ"
    },
    {
        "chapter": 8,
        "question": "Qual a diferen√ßa fundamental entre `DELETE FROM tabela;` (sem `WHERE`) e `TRUNCATE TABLE tabela;`?",
        "options": [
            "A) Nenhuma, ambas fazem exatamente a mesma coisa com a mesma performance.",
            "B) `DELETE` √© mais r√°pido pois n√£o precisa logar, enquanto `TRUNCATE` loga cada linha.",
            "C) `DELETE` remove linhas uma a uma (operac√£o DML, logada, dispara triggers), enquanto `TRUNCATE` remove todas as linhas de forma muito mais eficiente (geralmente DDL, minimamente logada, n√£o dispara triggers `ON DELETE`).",
            "D) `TRUNCATE` permite uma cl√°usula `WHERE`, enquanto `DELETE` sem `WHERE` apaga tudo."
        ],
        "correct_index": 2,
        "explanation": "`TRUNCATE` √© muito mais r√°pido para limpar uma tabela inteira, pois lida com as p√°ginas de dados de forma mais direta, com menos overhead de log e sem disparar triggers de linha. Mas cuidado, geralmente n√£o pode ser desfeito com `ROLLBACK`! üßπüí®"
    },
    {
        "chapter": 8,
        "question": "O que √© o problema da 'atualiza√ß√£o perdida' (lost update problem) em um ciclo de 'ler-modificar-escrever' concorrente?",
        "options": [
            "A) Quando um `UPDATE` falha e os dados s√£o perdidos devido a um erro de disco.",
            "B) Quando duas transa√ß√µes leem o mesmo dado, ambas o modificam, e a escrita da segunda transa√ß√£o sobrescreve a escrita da primeira, fazendo com que as modifica√ß√µes da primeira sejam perdidas.",
            "C) Quando o log de transa√ß√µes perde o registro de um `UPDATE` bem-sucedido.",
            "D) Quando um `UPDATE` √© t√£o lento que o usu√°rio desiste e perde os dados que queria salvar."
        ],
        "correct_index": 1,
        "explanation": "Isso acontece quando transa√ß√µes concorrentes n√£o coordenam suas atualiza√ß√µes, e uma sobrescreve o trabalho da outra sem perceber. üíî"
    },
    {
        "chapter": 8,
        "question": "Como o 'Optimistic Locking' (Travamento Otimista) geralmente funciona para prevenir o problema da atualiza√ß√£o perdida?",
        "options": [
            "A) Bloqueando a linha com `SELECT ... FOR UPDATE` assim que ela √© lida, impedindo qualquer outra transa√ß√£o de acess√°-la.",
            "B) Utilizando uma coluna de vers√£o (ou timestamp); o `UPDATE` s√≥ √© permitido se a vers√£o da linha no banco n√£o mudou desde que foi lida, e a vers√£o √© incrementada na atualiza√ß√£o.",
            "C) Serializando todas as transa√ß√µes que tentam acessar a mesma tabela.",
            "D) Permitindo que as atualiza√ß√µes perdidas aconte√ßam, mas registrando-as para corre√ß√£o manual posterior."
        ],
        "correct_index": 1,
        "explanation": "O Travamento Otimista assume que conflitos s√£o raros. Ele verifica no momento do `UPDATE` se o dado foi alterado por outra transa√ß√£o (comparando a vers√£o). Se sim, o `UPDATE` falha (afeta 0 linhas) e a aplica√ß√£o lida com o conflito. ‚úÖ‚û°Ô∏è‚ùì‚û°Ô∏èüëç/üëé"
    },
    {
        "chapter": 8,
        "question": "Qual a principal desvantagem do 'Pessimistic Locking' (ex: `SELECT ... FOR UPDATE`) em ambientes com alta concorr√™ncia?",
        "options": [
            "A) √â mais complexo de implementar do que o Travamento Otimista.",
            "B) Pode levar a deadlocks com mais frequ√™ncia se n√£o for usado corretamente.",
            "C) Reduz a concorr√™ncia, pois as transa√ß√µes podem ter que esperar por longos per√≠odos para que os locks nas linhas sejam liberados, causando gargalos.",
            "D) N√£o √© suportado por todos os bancos de dados SQL padr√£o."
        ],
        "correct_index": 2,
        "explanation": "Ao bloquear linhas por per√≠odos mais longos, o Travamento Pessimista pode fazer com que muitas transa√ß√µes fiquem enfileiradas esperando, o que limita quantas opera√ß√µes podem ocorrer simultaneamente. ‚è≥üö∂üö∂üö∂"
    },
    {
        "chapter": 8,
        "question": "Se um ORM (como Hibernate/JPA) atualiza uma entidade enviando todos os seus campos mapeados na instru√ß√£o `UPDATE SQL`, mesmo que apenas um campo tenha mudado, por que isso pode ser um problema de performance, conforme discutido no livro?",
        "options": [
            "A) Isso n√£o √© um problema, pois os SGBDs modernos ignoram campos n√£o alterados no `SET`.",
            "B) Pode causar a atualiza√ß√£o desnecess√°ria de colunas indexadas, levando √† manuten√ß√£o custosa desses √≠ndices, al√©m de maior tr√°fego de rede e log.",
            "C) Principalmente porque aumenta o tamanho do objeto entidade na mem√≥ria da aplica√ß√£o.",
            "D) Apenas se a tabela tiver triggers `ON UPDATE` para cada coluna."
        ],
        "correct_index": 1,
        "explanation": "Se colunas indexadas s√£o inclu√≠das no `SET` de um `UPDATE` (mesmo que seus valores n√£o tenham mudado em rela√ß√£o ao que j√° est√° no banco), o SGBD pode ainda ter que fazer trabalho de manuten√ß√£o nesses √≠ndices, o que √© ineficiente. Configura√ß√µes como `@DynamicUpdate` (Hibernate) ou o uso de JPQL `UPDATE`s podem mitigar isso. üõ†Ô∏èüêå"
    }
]



