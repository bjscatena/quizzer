[
    {
        "chapter": 1,
        "question": "Qual √© a principal estrutura de dados que a maioria dos bancos de dados SQL relacionais utiliza para implementar √≠ndices?",
        "options": [
            "A) Hash Table",
            "B) B-Tree (ou suas varia√ß√µes como B+Tree)",
            "C) Linked List",
            "D) Red-Black Tree"
        ],
        "correct_index": 1,
        "explanation": "B-Trees (e suas varia√ß√µes como B+Trees) s√£o eficientes para buscas de valores exatos e varreduras de intervalo (range scans), sendo a estrutura padr√£o para √≠ndices devido ao seu balanceamento e performance logar√≠tmica. üå≥"
    },
    {
        "chapter": 1,
        "question": "O que um 'n√≥ folha' (leaf node) em um √≠ndice B-Tree normalmente cont√©m, al√©m do valor da chave indexada?",
        "options": [
            "A) Apenas ponteiros para outros n√≥s folha.",
            "B) Um ponteiro para a linha de dados real na tabela (ex: ROWID) e, em B+Trees, ponteiros para os n√≥s folha vizinhos.",
            "C) Uma c√≥pia completa de todas as outras colunas da tabela.",
            "D) Metadados sobre a estrutura da B-Tree."
        ],
        "correct_index": 1,
        "explanation": "Os n√≥s folha de um √≠ndice B-Tree (especialmente B+Tree) cont√™m os valores das chaves indexadas, um ponteiro (como ROWID) para a localiza√ß√£o da linha completa na tabela (heap table) e ponteiros para os n√≥s folha adjacentes para facilitar varreduras de intervalo. üçÉ"
    },
    {
        "chapter": 1,
        "question": "O que significa o termo 'SARGable' (Search Argument Able) em rela√ß√£o a um predicado na cl√°usula WHERE?",
        "options": [
            "A) Um predicado que s√≥ pode ser usado com argumentos do tipo string.",
            "B) Um predicado que √© muito complexo para o otimizador entender.",
            "C) Um predicado que est√° formulado de tal maneira que o banco de dados pode usar um √≠ndice para satisfaz√™-lo eficientemente.",
            "D) Um predicado que garante um 'Index-Only Scan'."
        ],
        "correct_index": 2,
        "explanation": "Um predicado SARGable (Search ARGument Able) permite que o mecanismo de busca do banco de dados use um √≠ndice para restringir o conjunto de linhas a serem examinadas, em vez de fazer um table scan. üëç"
    },
    {
        "chapter": 1,
        "question": "Qual das seguintes condi√ß√µes na cl√°usula WHERE √© MENOS prov√°vel de ser SARGable e, portanto, impedir o uso eficiente de um √≠ndice padr√£o na coluna `data_evento`?",
        "options": [
            "A) `WHERE data_evento = '2024-01-15'`",
            "B) `WHERE data_evento BETWEEN '2024-01-01' AND '2024-01-31'`",
            "C) `WHERE TO_CHAR(data_evento, 'YYYY') = '2024'`",
            "D) `WHERE data_evento > '2024-01-01'`"
        ],
        "correct_index": 2,
        "explanation": "Aplicar uma fun√ß√£o (como TO_CHAR) a uma coluna indexada no lado esquerdo do predicado geralmente torna o predicado non-SARGable para um √≠ndice padr√£o nessa coluna, pois o banco teria que calcular a fun√ß√£o para cada linha antes de comparar. FUNC(coluna) = valor üö´"
    },
    {
        "chapter": 1,
        "question": "O que √© um 'Table Access by Index ROWID' (ou equivalente) no plano de execu√ß√£o de uma consulta?",
        "options": [
            "A) Uma opera√ß√£o que indica que a consulta foi totalmente satisfeita pelo √≠ndice (Index-Only Scan).",
            "B) Uma opera√ß√£o onde o banco de dados usa o ROWID (ou ponteiro similar) obtido de uma varredura de √≠ndice para localizar e buscar a linha completa na tabela principal.",
            "C) Um erro que ocorre quando o ROWID n√£o √© encontrado.",
            "D) Uma opera√ß√£o que sempre √© mais r√°pida que um Full Table Scan."
        ],
        "correct_index": 1,
        "explanation": "Ap√≥s encontrar uma entrada de chave em um √≠ndice, se a consulta precisa de colunas n√£o presentes no √≠ndice, o banco de dados usa o ponteiro (ROWID) para acessar a tabela principal e buscar o restante dos dados da linha. üîç"
    },
    {
        "chapter": 1,
        "question": "Qual o principal benef√≠cio de um √≠ndice em termos de performance de `SELECT`?",
        "options": [
            "A) Reduzir o espa√ßo em disco usado pela tabela.",
            "B) Acelerar opera√ß√µes de `INSERT` e `UPDATE`.",
            "C) Reduzir o n√∫mero de blocos de dados que precisam ser lidos do disco para satisfazer uma consulta.",
            "D) Garantir a atomicidade das transa√ß√µes."
        ],
        "correct_index": 2,
        "explanation": "Os √≠ndices permitem que o banco de dados localize rapidamente as linhas que correspondem aos crit√©rios de uma consulta sem ter que varrer a tabela inteira, reduzindo significativamente o I/O de disco e o tempo de resposta. üíæ‚û°Ô∏è‚ö°"
    },
    {
        "chapter": 1,
        "question": "Se uma consulta `SELECT col1, col2 FROM tabela WHERE col3 = 100` √© executada, e existe um √≠ndice apenas na `col3`, qual √© um resultado prov√°vel no plano de execu√ß√£o se `col1` e `col2` n√£o estiverem nesse √≠ndice?",
        "options": [
            "A) Full Table Scan, porque `col1` e `col2` n√£o est√£o no √≠ndice.",
            "B) Index Scan em `col3` seguido de Table Access by ROWID para buscar `col1` e `col2`.",
            "C) Index-Only Scan, pois a condi√ß√£o `WHERE` usa um √≠ndice.",
            "D) O banco criar√° um √≠ndice tempor√°rio em `col1` e `col2`."
        ],
        "correct_index": 1,
        "explanation": "O √≠ndice em `col3` ser√° usado para encontrar as linhas relevantes (Index Scan). Como `col1` e `col2` n√£o est√£o nesse √≠ndice, o banco precisar√° acessar a tabela principal (Table Access) para obter esses valores para as linhas encontradas. üéØ"
    },
    {
        "chapter": 1,
        "question": "O que √© 'seletividade' (selectivity) de um valor em uma coluna indexada?",
        "options": [
            "A) A capacidade de um √≠ndice selecionar todas as colunas da tabela.",
            "B) Uma medida de qu√£o poucas linhas um valor espec√≠fico da coluna indexada retorna; alta seletividade significa que o valor √© raro e retorna poucas linhas.",
            "C) A garantia de que a consulta `SELECT` usar√° o √≠ndice, independentemente do valor.",
            "D) O n√∫mero de colunas inclu√≠das em um √≠ndice."
        ],
        "correct_index": 1,
        "explanation": "Alta seletividade (um valor que aparece em poucas linhas) torna o √≠ndice muito eficaz para esse valor, pois ele restringe drasticamente o conjunto de resultados. Baixa seletividade (um valor que aparece em muitas linhas) torna o √≠ndice menos √∫til para esse valor espec√≠fico. üìä"
    },
    {
        "chapter": 1,
        "question": "A profundidade de uma B-Tree (n√∫mero de n√≠veis do topo √† folha) geralmente cresce de que forma em rela√ß√£o ao n√∫mero de linhas na tabela?",
        "options": [
            "A) Linearmente (ex: dobrar as linhas dobra a profundidade).",
            "B) Exponencialmente (ex: dobrar as linhas quadruplica a profundidade).",
            "C) Logaritmicamente (ex: a profundidade cresce muito lentamente, mesmo com um grande aumento de linhas).",
            "D) Permanece constante ap√≥s a B-Tree atingir 3 n√≠veis."
        ],
        "correct_index": 2,
        "explanation": "A profundidade de uma B-Tree cresce logaritmicamente com o n√∫mero de entradas. Isso √© fundamental para sua efici√™ncia, pois mesmo para tabelas com milh√µes ou bilh√µes de linhas, a profundidade do √≠ndice permanece pequena (geralmente 3 a 5 n√≠veis), garantindo buscas r√°pidas. üê¢‚û°Ô∏èüêá"
    },
    {
        "chapter": 1,
        "question": "Considerando um √≠ndice na coluna `status_pedido` (que pode ter valores como 'PENDENTE', 'PAGO', 'ENVIADO', 'CANCELADO'), qual tipo de consulta se beneficiaria MENOS desse √≠ndice se a distribui√ß√£o de status for muito desigual (ex: 90% dos pedidos est√£o como 'ENVIADO')?",
        "options": [
            "A) `WHERE status_pedido = 'PENDENTE'` (supondo que 'PENDENTE' √© raro)",
            "B) `WHERE status_pedido = 'ENVIADO'` (supondo que 'ENVIADO' √© muito comum)",
            "C) `WHERE status_pedido IN ('PENDENTE', 'PAGO')` (supondo que ambos s√£o raros)",
            "D) Todas as consultas se beneficiariam igualmente."
        ],
        "correct_index": 1,
        "explanation": "Um √≠ndice √© menos eficaz (e o otimizador pode at√© optar por n√£o us√°-lo) para buscar valores de baixa seletividade, ou seja, valores que aparecem em uma grande porcentagem das linhas da tabela. Se 'ENVIADO' √© muito comum, buscar por ele pode resultar na leitura de grande parte da tabela de qualquer maneira. üìâ"
    }
]
